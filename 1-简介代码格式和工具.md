在本章中，我们将探索与整洁代码相关的第一个概念，从它是什么和它的含义开始。本章的主要目标是理解整洁的代码不仅仅是软件项目中的一件好事或奢侈品。这是必需品。如果没有高质量的代码，项目将面临由于技术债务累积而失败的危险（技术债务是我们将在本章后面详细讨论的内容，所以如果您之前没有听说过这个术语，请不要担心） .

沿着相同的路线，但更详细的是格式化和记录代码的概念。这些听起来也像是多余的要求或任务，但同样，我们会发现它们在保持代码库的可维护性和可操作性方面发挥着重要作用。

我们将分析为该项目采用良好编码指南的重要性。意识到保持代码与引用对齐是一项持续的任务，我们将了解如何从自动化工具中获得帮助，从而简化我们的工作。出于这个原因，我们将讨论如何配置将作为构建的一部分在项目上自动运行的工具。

本章的目标是了解什么是整洁的代码，为什么它很重要，为什么格式化和记录代码是至关重要的任务，以及如何自动化这个过程。由此，您应该获得快速组织新项目结构的思维方式，旨在获得良好的代码质量。

阅读本章后，您将了解以下内容：

- 整洁的代码确实意味着比格式化更重要的事情
- 为了可维护性，具有标准格式是软件项目中的关键组件
- 如何使用 Python 提供的功能使代码自文档化
- 如何配置工具以自动对代码进行静态验证

## 介绍

我们将首先了解什么是整洁代码，以及为什么这对于软件工程项目的成功很重要。在前两节中，我们将了解保持良好的代码质量对于高效工作的重要性。

然后我们将讨论这些规则的一些例外情况：也就是说，在这种情况下，不重构我们的代码来偿还所有技术债务甚至可能具有成本效益。毕竟，我们不能简单地期望通用规则适用于所有地方，因为我们知道有例外。这里的重要一点是正确理解为什么我们愿意破例并正确识别这些类型的情况。我们不想误导自己认为某些东西不应该改进，而实际上它应该改进。

### 整洁代码的意义

整洁的代码没有唯一或严格的定义。此外，可能没有正式衡量整洁代码的方法，因此您无法在存储库上运行工具来告诉您代码的好坏或可维护性。当然，您可以运行**checkers**、**linter**、**static analyzers**等工具，这些工具很有帮助。它们是必要的，但还不够。整洁的代码不是机器或脚本可以识别的（到目前为止），而是我们作为专业人士可以决定的。

几十年来，我们一直认为编程语言是为了将我们的想法传达给机器，以便机器运行我们的程序。我们错了。这不是真相，而是真相的一部分。 “编程语言”中“语言”部分的真正含义是将我们的想法传达给其他开发人员。

这就是整洁代码的真正本质所在。能否阅读和维护代码取决于其他工程师。因此，作为专业人士，我们是唯一可以判断这一点的人。想一想；作为开发人员，我们花在阅读代码上的时间比实际编写代码的时间要多得多。每次我们想要进行更改或添加新功能时，我们首先必须阅读我们必须修改或扩展的代码的所有环境。语言 (Python) 是我们用来相互交流的语言。

所以，与其给你一个整洁代码的定义（或我的定义），我邀请你通读这本书，阅读所有关于惯用 Python 的内容，看看好代码和坏代码之间的区别，确定好代码和好的架构的特征，然后提出你自己的定义。读完本书，你将能够自己判断和分析代码，对整洁代码会有更清晰的认识。不管给了你什么定义，你都会知道它是什么以及它意味着什么。

### 拥有整洁代码的重要性

整洁代码很重要的原因有很多。他们中的大多数都围绕着可维护性、减少技术债务、有效地进行敏捷开发以及管理成功的项目的想法。

我想探讨的第一个想法是关于敏捷开发和持续交付。如果我们希望我们的项目以稳定和可预测的速度不断地成功交付功能，那么必须拥有一个良好且可维护的代码库。

想象一下，您正在路上驾驶汽车前往您想要在某个时间点到达的目的地。您必须估计您的到达时间，以便您可以告诉等待您的人。如果汽车运转良好，道路平坦且完美，那么我不明白为什么您会大大错过您的估计。但是，如果道路状况不佳，您必须下车将石块移开，或避免出现裂缝，每隔几公里就停下来检查发动机，那么您不太可能确定何时到达即将到达（或者如果您将到达）。我认为这个比喻很清楚；道路就是代码。如果您想以稳定、恒定和可预测的速度前进，则代码需要可维护和可读。如果不是，每次产品管理要求新功能时，您都必须停下来重构并修复技术债务。

技术债务是指由于妥协或做出错误决定而导致软件出现问题的概念。可以从两种方式来考虑技术债务。从现在到过去：如果我们目前面临的问题是以前编写的糟糕代码的结果怎么办？而且，从现在到未来：如果我们现在决定走捷径，而不是在适当的解决方案上投入时间，那么我们会在更远的地方为自己制造什么问题？

债务这个词是一个不错的选择。这是债务，因为代码在未来更改将比现在更难修改。发生的成本是债务的利息。招致技术债务意味着明天，修改代码将比今天更难、更昂贵（甚至有可能对此进行衡量），甚至在后天更昂贵，依此类推。

每次团队不能按时交付某些东西而不得不停下来修复和重构代码时，它就是在付出技术债务的代价。

甚至有人可能会争辩说，拥有一个带有技术债务的代码库的团队并不是在进行敏捷软件开发。因为，敏捷的反面是什么？死板的。如果代码充斥着代码异味，那么它就无法轻易更改，因此团队无法快速响应需求变化并持续交付。

技术债务最糟糕的地方在于它代表了一个长期的、潜在的问题。这不是引起警报的事情。相反，它是一个无声的问题，分散在项目的所有部分，总有一天，在某个特定的时间，它会醒来并成为一个表演者。

在一些更令人担忧的情况下，“技术债务”甚至是轻描淡写，因为问题要严重得多。在前面的段落中，我提到了技术债务使团队在未来更难做事情的场景，但如果现实更加危险怎么办？想象一下走捷径，使代码处于脆弱的位置（一个简单的例子可能是函数中的可变默认参数会导致内存泄漏，我们将在后面的章节中看到）。您可以部署您的代码，它会在很长一段时间内正常工作（只要该缺陷不表现出来）。但这实际上是等待发生的崩溃：有一天，在最意想不到的情况下，将满足代码中的特定条件，这将导致应用程序运行时出现问题，例如代码中的定时炸弹在随机时间爆炸.

我们显然希望避免上述情况。并非所有东西都可以被自动化工具捕获，但只要有可能，这是一项不错的投资。其余的依赖于良好、彻底的代码审查和良好的自动化测试。

软件只有在可以轻松更改的程度上才有用。我们创建软件来响应某些需求（无论是购买机票、网上购物还是听音乐，仅举几个例子）。这些需求很少被冻结，这意味着一旦导致该软件被首先编写的上下文中的某些内容发生变化，该软件就必须更新。如果代码不能改变（我们知道现实确实会改变），那么它就没用了。拥有整洁的代码库是对其进行修改的绝对要求，因此整洁代码的重要性不言而喻。

### 一些例外

在上一节中，我们探讨了整洁的代码库对软件项目成功的关键作用。也就是说，请记住这是一本针对从业者的书，因此务实的读者可能会正确地指出这引出了一个问题：“这有合法的例外吗？”

当然，如果它不允许读者挑战其中的一些假设，这将不是一本真正务实的书。

事实上，在某些情况下，您可能想要考虑放宽拥有原始代码库的一些限制。以下是可能证明跳过某些质量检查的情况的列表（绝不是详尽无遗的）：

- 编程马拉松
- 如果您正在为一次性任务编写一个简单的脚本
- 代码竞赛
- 在开发概念证明时
- 在开发原型时（只要你确定它确实是一个会被扔掉的原型）
- 当您正在处理一个将被弃用的遗留项目时，并且它仅在固定的、短暂的时间内处于维护模式（再次，如果这是有保证的）

在这些情况下，常识适用。例如，如果您刚刚接触到一个项目，该项目将只在接下来的几个月内运行，直到它退役，那么可能不值得去解决所有继承的技术债务的所有麻烦，并等待它存档可能是更好的选择。

请注意，这些示例都有一个共同点，即它们假设代码可以承受不以高质量标准编写，也是我们永远不必再次查看的代码。这与之前公开的内容是一致的，可以被认为是我们原始前提的反建议：我们编写整洁的代码是因为我们想要实现高可维护性。如果不需要维护该代码，那么我们可以跳过维护高质量标准的工作。

请记住，我们编写整洁的代码是为了维护项目。这意味着将来能够自己修改该代码，或者，如果我们将该代码的所有权移交给公司中的另一个团队，则使这种转换（以及未来维护者的生活）更容易。这意味着，如果一个项目仅处于维护模式，但不会被弃用，那么它可能仍然是偿还技术债务的好投资。这是因为在某些时候（通常是在最不期望的时候），会有一个必须修复的错误，并且代码尽可能具有可读性将是有益的。

## 代码格式化

整洁的代码仅与代码的格式和结构有关吗？最简洁的答案是不。

有一些编码标准，如 PEP-8 (https://www.python.org/dev/peps/pep-0008/)，规定了应如何编写和格式化代码。在 Python 中，PEP-8 是最著名的标准，该文档提供了关于我们应该如何编写程序的指南，包括间距、命名约定、行长等。

然而，整洁的代码远远超出了编码标准、格式、linting 工具和其他有关代码布局的检查。整洁的代码是关于获得高质量的软件和构建一个健壮和可维护的系统。一段代码或整个软件组件可以 100% 符合 PEP-8（或任何其他指南），但仍不能满足这些要求。

尽管格式化不是我们的主要目标，但不注意代码结构也有一些危险。为此，我们将首先分析代码结构不好的问题以及如何解决这些问题。之后，我们将看到如何为 Python 项目配置和使用工具来自动检查最常见的问题。

总而言之，我们可以说整洁的代码与 PEP-8 或编码风格无关。它远不止于此，它对代码的可维护性和软件的质量更有意义。然而，正如我们将看到的，正确格式化代码对于高效工作很重要。

### 遵守项目的编码风格指南

编码指南是一个项目应该被认为是在质量标准下开发的最低限度。在本节中，我们将探讨这背后的原因。在以下部分中，我们可以开始寻找使用工具自动执行此操作的方法。

当我试图在代码布局中找到好的特性时，我想到的第一件事就是一致性。我希望代码结构一致，以便于阅读和遵循。如果代码不正确或结构不统一，并且团队中的每个人都以自己的方式做事，那么我们最终会得到需要额外努力和注意力才能理解的代码。它将容易出错、误导，并且错误或微妙之处可能很容易漏掉。

我们想避免这种情况。我们想要的恰恰相反——我们可以一目了然地尽快阅读和理解的代码。

如果开发团队的所有成员就构建代码的标准化方式达成一致，则生成的代码看起来会更加熟悉。因此，您将快速识别模式（稍后将详细介绍），并且记住这些模式，理解事物和检测错误会容易得多。例如，当有什么不对劲时，你会注意到，不知何故，你习惯看到的模式中有一些奇怪的东西，这会引起你的注意。你会仔细观察，你很可能会发现错误！

正如经典著作 Code Complete 中所述，在题为 Perceptions in Chess (1973) 的论文中对此进行了有趣的分析，其中进行了一项实验，以确定不同的人如何理解或记住不同的国际象棋位置。该实验针对所有级别（新手、中级和国际象棋大师）的棋手进行，并在棋盘上具有不同的棋位。他们发现，当位置随机时，新手和国际象棋大师一样；这只是一种记忆练习，任何人都可以在合理的相同水平上进行。当这些位置遵循在真实游戏中可能发生的逻辑顺序时（同样，一致性，坚持模式），那么国际象棋大师的表现要比其他人好得多。

现在想象一下同样的情况应用于软件。我们作为 Python 的软件工程师专家，就像前面例子中的国际象棋大师。如果代码结构随意，不遵循任何逻辑，不遵循任何标准，那么我们作为新手开发人员就很难发现错误。另一方面，如果我们习惯于以结构化的方式阅读代码，并且我们已经学会了通过遵循模式从代码中快速获取想法，那么我们就处于相当大的优势。

特别是，对于 Python，您应该遵循的那种编码风格是 PEP-8。您可以将其扩展或采用其某些部分以适应您正在处理的项目的特殊性（例如，行的长度、有关字符串的注释等）。

如果您意识到您正在从事的项目不符合任何编码标准，请推动在该代码库中采用 PEP-8。理想情况下，您所在的公司或团队应该有一份书面文件，解释预期要遵循的编码标准。这些编码指南可以是 PEP-8 的改编版。

> 如果您发现您的团队与代码风格不一致，并且在代码审查期间对此进行了多次讨论，那么重新审视编码指南并投资于自动验证工具可能是个好主意。

特别是，PEP-8 触及了您不想在项目中错过的质量特征的一些重要点； 他们之中有一些是：

- 可搜索性：是指能够一眼识别代码中的token； 也就是说，在某些文件（以及这些文件的哪个部分）中搜索我们正在寻找的特定字符串。 PEP-8 的一个关键点是它区分了将值分配给变量的方式，以及传递给函数的关键字参数。 为了更好地理解这一点，让我们举一个例子。 假设我们正在调试，我们需要找到传递给名为 location 的参数的值的位置。 我们可以运行以下 grep 命令，结果将告诉我们要查找的文件和行：

```bash
$ grep -nr "location=" . 
./core.py:13: location=current_location,
```

现在，我们想知道这个变量在哪里被分配了这个值，下面的命令也会给我们我们正在寻找的信息：

```shell
$ grep -nr "location =" .
./core.py:10: current_location = get_location()
```

PEP-8 建立了一个约定，当通过关键字向函数传递参数时，我们不使用空格，但在为变量设置值时使用空格。出于这个原因，我们可以调整我们的搜索条件（在第一个示例中 = 周围没有空格，在第二个示例中一个空格）并提高我们的搜索效率。这是遵循惯例的优点之一。

- 一致性：如果代码格式统一，阅读起来会容易很多。这对于入职尤其重要，如果您想欢迎新的开发人员加入您的项目，或者甚至在您的团队中雇用新的（可能是经验不足的）程序员，并且他们需要熟悉代码（甚至可能由多个存储库组成） ）。如果代码布局、文档、命名约定等在他们打开的所有存储库中的所有文件中都相同，这将使他们的生活变得更加轻松。
- 更好的错误处理：PEP-8 中提出的建议之一是将 try/except 块内的代码量限制到尽可能少。这减少了错误面，从某种意义上说，它减少了意外吞下异常和掩盖错误的可能性。可以说，这可能很难通过自动检查来强制执行，但在执行代码审查时仍然值得关注。
- 代码质量：通过以结构化的方式查看代码，您将更熟练地一目了然地理解它（同样，就像在国际象棋中的感知一样），并且您将更容易发现错误和错误。除此之外，检查代码质量的工具也会暗示潜在的错误。代码的静态分析可能有助于降低每行代码的错误率。
    正如我在介绍中提到的，格式化是整洁代码的必要部分，但它并不止于此。还有更多的考虑因素需要考虑，例如在代码中记录设计决策以及使用工具尽可能地利用自动质量检查。在下一节中，我们从第一个开始。

## 文档

本节是关于从代码内部记录 Python 中的代码。好的代码是不言自明的，但也有很好的文档记录。最好解释一下它应该做什么（而不是如何做）。

一个重要的区别：记录代码与添加注释不同。本节旨在探索文档字符串和注释，因为它们是 Python 中用于记录代码的工具。也就是说，顺便说一下，我将简要介绍代码注释的主题，只是为了建立一些可以更清晰区分的要点。

代码文档在 Python 中很重要，因为是动态类型的，很容易在函数和方法中的变量或对象的值中迷失。出于这个原因，说明这些信息将使未来的代码读者更容易。

还有另一个原因与注释特别相关。它们还可以通过 mypy (http://mypy-lang.org/) 或 pytype (https://google.github.io/pytype/) 等工具帮助运行一些自动检查，例如类型提示。我们会发现，最终，添加注释是有回报的。

### 代码注释

作为一般规则，我们应该尽量减少代码注释。 那是因为我们的代码应该是自文档化的。 这意味着，如果我们努力使用正确的抽象（例如将代码中的职责划分为有意义的函数或对象），并且我们清楚地命名事物，则不需要注释。

> 在撰写注释之前，请尝试查看是否可以仅使用代码（即通过添加新函数或使用更好的变量名称）来表达相同的含义。

本书中关于注释的观点与软件工程的其他文献非常一致：代码中的注释是我们无法正确表达代码的症状。

但是，在某些情况下，在代码中添加注释是不可能避免的，不这样做会很危险。通常情况下，代码中的某些内容必须针对乍一看并非微不足道的特定技术细微差别进行处理（例如，如果底层外部函数中存在错误并且我们需要传递特殊参数来规避该问题） .在这种情况下，我们的任务是尽可能简洁，并以最好的方式解释问题是什么，以及为什么我们在代码中采用这种特定路径，以便读者能够理解这种情况。

最后，代码中有另一种绝对糟糕的注释，而且没有办法证明它是正确的：***注释掉代码***。必须无情地删除此代码。请记住，代码是开发人员之间的一种交流语言，是设计的最终表达。代码就是知识。注释掉的代码会带来混乱（并且很可能是矛盾），这会污染知识。

没有充分的理由，尤其是现在，使用现代版本控制系统，留下可以简单删除（或藏在其他地方）的注释掉的代码。

总结一下：代码注释是邪恶的。有时是必要的邪恶，但我们应该尽量避免。另一方面，代码文档则有所不同。这是指在代码本身中记录设计或架构，以使其清晰，这是一种积极的力量（也是下一节的主题，我们将在其中讨论文档字符串）。

### 文档字符串

简单来说，我们可以说文档字符串是嵌入在源代码中的文档。文档字符串基本上是一个文字字符串，放置在代码中的某个位置以记录该部分逻辑。

请注意对文档一词的强调。这很重要，因为它旨在代表解释，而不是证明。文档字符串不是注释；它们是文档。

文档字符串旨在为代码中的特定组件（模块、类、方法或函数）提供对其他开发人员有用的文档。这个想法是，当其他工程师想要使用您正在编写的组件时，他们很可能会查看文档字符串以了解它应该如何工作，预期的输入和输出是什么，等等。出于这个原因，尽可能添加文档字符串是一个很好的做法。

文档字符串对于记录设计和架构决策也很有用。向最重要的 Python 模块、函数和类添加文档字符串可能是一个好主意，以便向读者提示该组件如何适应整体架构。

在代码中使用它们是一件好事（或者甚至可能需要，取决于您的项目标准）的原因是 Python 是动态类型的。这意味着，例如，一个函数可以将任何值作为其任何参数的值。 Python 不会强制执行，也不会检查这样的事情。因此，想象一下您在代码中发现了一个必须修改的函数。你甚至很幸运，函数有一个描述性的名字，它的参数也有。可能仍然不太清楚您应该向它传递什么类型。即使是这种情况，它们又该如何使用？

这是一个好的文档字符串可能有帮助的地方。记录一个函数的预期输入和输出是一个很好的做法，它将帮助该函数的读者理解它应该如何工作。

> 要运行以下代码，您需要一个 IPython (https://ipython.org/) 交互式 shell，其中 Python 版本根据本书的要求设置。 如果您没有 IPython shell，您仍然可以通过替换 <function>?? 有帮助（<功能>）。

考虑来自标准库的这个很好的例子：

```
Type: method_descriptor
```

在这里，字典上 update 方法的文档字符串为我们提供了有用的信息，它告诉我们可以以不同的方式使用它：

1.我们可以使用 .keys() 方法传递一些东西（例如，另一个字典），它将使用每个参数传递的对象中的键更新原始字典：

```python
>>> d = {}
>>> d.update({1: "one", 2: "two"})
>>> d
{1: "one", 2: 'two'}
```

2.我们可以传递一个可迭代的键和值对，我们将解包它们以进行更新：

```python
>>> d.update([(3, "three"), (4, "four")])
>>> d
{1: 'one', 2: 'two', 3: 'three', 4: 'four'}
```

3.它还告诉我们，我们可以使用从关键字参数中获取的值来更新字典：

```python
>>> d.update(five=5)
>>> d
{1: 'one', 2: 'two', 3: 'three', 4: 'four', 'five': 5}
```

（请注意，在这种形式中，关键字参数是字符串，因此我们不能以 5="five" 形式设置某些内容，因为它是不正确的。）

对于想要学习和了解新功能的工作原理以及如何利用它的人来说，此信息至关重要。

请注意，在第一个示例中，我们通过在函数上使用双问号（dict.update??）获得了函数的文档字符串。这是 IPython 交互式解释器 (https://ipython.org/) 的一个特性。当它被调用时，它将打印您期望的对象的文档字符串。现在，想象以同样的方式，我们从标准库的这个函数中获得了帮助；如果您将文档字符串放在您编写的函数上，以便其他人可以以相同的方式理解他们的工作，那么您能让读者（您的代码的用户）的生活变得更轻松吗？

文档字符串不是与代码分离或隔离的东西。它成为代码的一部分，您可以访问它。当一个对象定义了一个文档字符串时，它会通过它的 \_\_doc\_\_ 属性成为它的一部分：

```python
>>> def my_function():
        """Run some computation"""
        return None
     ...
>>> my_function.__doc__  # or help(my_function)
 'Run some computation'
```

这意味着甚至可以在运行时访问它，甚至可以从源代码生成或编译文档。事实上，有一些工具可以做到这一点。如果您运行 Sphinx，它将为您的项目文档创建基本脚手架。特别是使用 autodoc 扩展 (sphinx.ext.autodoc)，该工具将从代码中获取文档字符串并将它们放置在记录函数的页面中。

一旦您拥有构建文档的工具，请将其公开，使其成为项目本身的一部分。对于开源项目，您可以使用 read the docs (https://readthedocs.org/)，它将按分支或版本（可配置）自动生成文档。对于公司或项目，您可以使用相同的工具或在本地配置这些服务，但不管这个决定如何，重要的部分是文档应该准备好并可供团队的所有成员使用。

不幸的是，文档字符串有一个缺点，那就是，就像所有文档一样，它需要手动和持续的维护。随着代码的变化，它必须更新。另一个问题是，要使文档字符串真正有用，它们必须详细，这需要多行。考虑到这两个因素，如果您编写的函数非常简单且不言自明，最好避免添加稍后需要维护的冗余文档字符串。

维护正确的文档是我们无法逃避的软件工程挑战。像这样也是有道理的。如果您考虑一下，手动编写文档的原因是因为它旨在供其他人阅读。如果它是自动化的，它可能没有多大用处。为了使文档具有任何价值，团队中的每个人都必须同意这是需要人工干预的东西，因此需要付出努力。关键是要了解软件不仅仅是代码。随附的文档也是可交付成果的一部分。因此，当有人对函数进行更改时，同样重要的是将文档的相应部分更新为刚刚更改的代码，无论是 wiki、用户手册、README 文件还是多个文档字符串。

### 注解

PEP-3107 引入了注解的概念。 它们的基本思想是向代码的读者提示函数中参数值的期望值。 提示一词的使用并非随意； 注解启用类型提示，我们将在本章稍后在第一次介绍注解之后讨论。

注解让您可以指定某些已定义变量的预期类型。 它实际上不仅与类型有关，而且与任何类型的元数据有关，可以帮助您更好地了解该变量实际代表什么。

考虑以下示例：

```python
@dataclass
class Point
    lat: float
    long: float
 
 
def locate(latitude: float, longitude: float) -> Point:
    """Find an object in the map by its coordinates"""
```

在这里，我们使用浮点数来表示预期的纬度和经度类型。 这只是为函数的读者提供信息，以便他们可以了解这些预期类型。 Python 不会检查这些类型，也不会强制执行它们。

我们还可以指定函数返回值的预期类型。 在这种情况下，Point 是一个用户定义的类，因此这意味着返回的任何内容都将是 Point 的一个实例。

但是，类型或内置函数并不是我们可以用作注解的唯一类型。 基本上，在当前 Python 解释器范围内有效的所有内容都可以放在那里。 例如，解释变量意图的字符串、用作回调或验证函数的可调用对象等。

我们可以利用注解使我们的代码更具表现力。 考虑下面的示例，该函数应该启动一个任务，但它也接受一个参数来延迟执行：

```python
def launch_task(delay_in_seconds):
    ...
```

在这里，参数 delay_in_seconds 的名称似乎很冗长，但尽管如此，它仍然没有提供太多信息。 什么是可接受的秒数？ 它考虑分数吗？

我们在代码中回答这些问题如何？

```python
Seconds = float
def launch_task(delay: Seconds):
    ...
```

现在代码不言自明。 此外，我们可以争辩说，随着 Seconds 注解的引入，我们围绕如何解释代码中的时间创建了一个小抽象，并且我们可以在代码库的更多部分中重用这种抽象。 如果我们稍后决定在几秒钟内更改底层抽象（假设从现在开始，只允许使用整数），我们可以在一个地方进行更改。

随着注解的引入，还包含了一个新的特殊属性，就是\_\_annotations\_\_。 这将使我们能够访问一个字典，该字典将注解的名称（作为字典中的键）与其对应的值（我们为它们定义的值）进行映射。 在我们的示例中，这将如下所示：

```python
>>> locate.__annotations__
{'latitude': <class 'float'>, 'longitude': <class 'float'>, 'return': <class 'Point'>}
```

如果我们认为必要，我们可以用它来生成文档、运行验证或在我们的代码中执行检查。

说到通过注解检查代码，这就是 PEP-484 发挥作用的时候。 此 PEP 指定了类型提示的基础知识； 通过注解检查函数类型的想法。 再次澄清一下，并引用 PEP-484 本身：

> “Python 仍将是一种动态类型语言，即使按照惯例，作者也不希望强制类型提示。”

类型提示的想法是拥有额外的工具（独立于解释器）来检查整个代码中类型的正确使用，并在检测到任何不兼容时提示用户。有一些有用的工具可以检查数据类型以及它们在我们的代码中的使用方式，以便发现潜在的问题。一些示例工具，如 mypy 和 pytype，在工具部分有更详细的解释，我们将在那里讨论如何使用和配置项目的工具。现在，您可以将其视为一种检查代码中使用的类型语义的 linter。出于这个原因，在项目上配置 mypy 或 pytype 并在与其他静态分析工具相同的级别使用它是一个好主意。

然而，类型提示不仅仅意味着检查我们代码中的类型的工具。继我们之前的示例之后，我们可以为代码中的类型创建有意义的名称和抽象。对于处理客户端列表的函数，请考虑以下情况。以最简单的形式，只需使用通用列表即可对其进行注解：

```python
def process_clients(clients: list):
    ...
```

如果我们知道在我们当前的数据建模中，客户端表示为整数和文本的元组，我们可以添加更多细节：

```python
def process_clients(clients: list[tuple[int, str]]):
    ...
```

但这仍然没有为我们提供足够的信息，因此最好明确并为该别名命名，因此我们不必推断该类型的含义：

```python
from typing import Tuple
Client = Tuple[int, str]
def process_clients(clients: list[Client]):
```

在这种情况下，含义更清晰，并且支持不断发展的数据类型。也许元组是适合问题以正确表示客户端的最小数据结构，但稍后，我们将要为另一个对象更改它或创建一个特定的类。在这种情况下，注解将保持正确，所有其他类型验证也是如此。

这背后的基本思想是，现在语义扩展到更有意义的概念，使我们（人类）更容易理解代码的含义，或在给定点的预期。

注解带来了额外的好处。随着 PEP-526 和 PEP-557 的引入，有一种以紧凑的方式编写类和定义小型容器对象的便捷方法。这个想法是在一个类中声明属性，并使用注解来设置它们的类型，在@dataclass 装饰器的帮助下，它们将作为实例属性处理，而不必在 \_\_init\_\_ 方法中显式声明它并将值设置为他们：

```python
from dataclasses import dataclass
@dataclass
class Point:
    lat: float
    long: float
```

```python
>>> Point.__annotations__
{'lat': <class 'float'>, 'long': <class 'float'>}
>>> Point(1, 2)
Point(lat=1, long=2)
```

在本书的后面，我们将探索注解的其他重要用途，更多地与代码设计相关。 当我们探索面向对象设计的良好实践时，我们可能想要使用诸如依赖注入之类的概念，在这些概念中，我们将代码设计为依赖于声明契约的接口。 声明代码依赖于特定接口的最好方法可能是使用注解。 更重要的是，有一些工具专门使用 Python 注解来自动提供对依赖注入的支持。

在设计模式中，我们通常还希望将部分代码与具体实现解耦，并依赖抽象接口或契约，使我们的代码更加灵活和可扩展。 此外，设计模式通常通过创建所需的适当抽象来解决问题（这通常意味着拥有封装部分逻辑的新类）。 在这两种情况下，注解我们的代码都会有额外的帮助。

### 注解会代替文档字符串吗？

这是一个有效的问题，因为在旧版本的 Python 中，早在引入注解之前，记录函数或属性的参数类型的方法是将文档字符串放在它们上面。关于如何构建文档字符串以包含函数的基本信息，包括每个参数的类型和含义、返回值以及函数可能引发的可能异常，甚至还有一些格式约定。

大部分问题已经通过注解以更紧凑的方式解决了，所以人们可能想知道是否真的值得拥有文档字符串。答案是肯定的，这是因为它们相辅相成。

确实，以前包含在文档字符串中的一部分信息现在可以移动到注解中（不再需要在文档字符串中指明参数的类型，因为我们可以使用注解）。但这只会为更好的文档字符串文档留出更多空间。特别是，对于动态和嵌套数据类型，提供预期数据的示例总是一个好主意，以便我们可以更好地了解我们正在处理的内容。

考虑以下示例。假设我们有一个函数需要字典来验证一些数据：

```python
def data_from_response(response: dict) -> dict:
    if response["status"] != 200:
        raise ValueError
    return {"data": response["payload"]}
```

在这里，我们可以看到一个函数，它接受一个字典并返回另一个字典。 如果键“状态”下的值不是预期的值，它可能会引发异常。 但是，我们没有更多关于它的信息。 例如，响应对象的正确实例是什么样的？ 结果的实例会是什么样子？ 要回答这两个问题，最好记录预期由参数传入并由此函数返回的数据示例。

让我们看看我们是否可以在文档字符串的帮助下更好地解释这一点：

```python
def data_from_response(response: dict) -> dict:
    """If the response is OK, return its payload.
 
    - response: A dict like::
 
    {
        "status": 200, # <int>
        "timestamp": "....", # ISO format string of the current
        date time
        "payload": { ... } # dict with the returned data
    }
 
    - Returns a dictionary like::
 
    {"data": { .. } }
 
    - Raises:
    - ValueError if the HTTP status is != 200
    """
    if response["status"] != 200:
        raise ValueError
    return {"data": response["payload"]}
```

现在，我们对这个函数预期接收和返回的内容有了更好的了解。 文档作为有价值的输入，不仅用于理解和了解正在传递的内容，而且作为单元测试的宝贵来源。 我们可以导出这样的数据用作输入，并且我们知道在测试中使用的正确和不正确的值是什么。 实际上，这些测试也可以作为我们代码的可操作文档，但这将在本书后面更详细地解释。

好处是现在我们知道键的可能值是什么，以及它们的类型，并且我们对数据的外观有了更具体的解释。 代价是，正如我们前面提到的，它占用了很多行，并且需要冗长和详细才能有效。

## 工具

在本节中，我们将探索如何配置一些基本工具并自动运行代码检查，目的是利用部分重复验证检查。

这一点很重要：请记住，代码是供我们这些人理解的，因此只有我们才能确定什么是好代码或什么是坏代码。我们应该花时间进行代码审查，思考什么是好的代码，以及它的可读性和可理解性。在查看同行编写的代码时，您应该提出以下问题：

- 这段代码是否易于理解并让其他程序员遵循？
- 它是否涉及问题的领域？
- 加入团队的新人是否能够理解它并有效地使用它？

正如我们之前看到的，代码格式、一致的布局和适当的缩进是必需的，但在代码库中还没有足够的特征。而且，这些都是我们作为具有高度质量意识的工程师认为理所当然的事情，因此我们会阅读和编写远远超出其布局基本概念的代码。因此，我们不愿意浪费时间审查这些类型的项目，因此我们可以通过查看代码中的实际模式来更有效地投入时间，以了解其真正含义并提供有价值的结果。

所有这些检查都应该是自动化的。它们应该是测试或检查表的一部分，而这又应该是持续集成构建的一部分。如果这些检查未通过，则使构建失败。这是真正确保代码结构始终保持连续性的唯一方法。它还可以作为团队参考的客观参数。与其让一些工程师或团队领导总是不得不在代码审查中指出关于 PEP-8 的相同评论，构建将自动失败，使其变得客观。

本节中介绍的工具将使您了解可以自动对代码执行的检查。这些工具应该执行一些标准。通常，它们是可配置的，并且每个存储库都有自己的配置是完全没问题的。

使用工具的想法是有一种可重复和自动的方式来运行某些检查。这意味着每个工程师都应该能够在他们的本地开发环境中运行这些工具，并获得与团队中任何其他成员相同的结果。而且，这些工具应该作为持续集成 (CI) 构建的一部分进行配置。

### 检查类型一致性

类型一致性是我们想要自动检查的主要内容之一。 Python 是动态类型化的，但我们仍然可以添加类型注释来提示读者（和工具）在代码的不同部分会发生什么。尽管注释是可选的，正如我们所见，添加它们是一个好主意，不仅因为它使代码更具可读性，还因为我们可以使用注释和一些工具来自动检查一些最有可能发生的常见错误错误。

由于 Python 中引入了类型提示，因此开发了许多用于检查类型一致性的工具。在本节中，我们将了解其中的两个：mypy (https://github.com/python/mypy) 和 pytype (https://github.com/google/pytype)。有多种工具，您甚至可以选择使用不同的工具，但总的来说，无论使用哪种特定工具，都适用相同的原则：重要的是要有一种自动验证更改的方式，并将这些验证添加为CI 构建。 mypy 是 Python 中可选静态类型检查的主要工具。这个想法是，一旦你安装它，它就会分析你项目中的所有文件，检查类型使用中的不一致。这很有用，因为在大多数情况下，它会及早检测到实际错误，但有时可能会产生误报。

可以用pip安装，建议将其作为项目的依赖包含在安装文件中：

```bash
$ pip install mypy
```

一旦它安装在虚拟环境中，你只需要运行前面的命令，它就会报告所有关于类型检查的结果。 尽量遵守其报告，因为在大多数情况下，它提供的见解有助于避免错误，否则这些错误可能会进入生产。 但是，该工具并不完美，因此如果您认为它报告的是误报，则可以忽略带有以下标记的该行作为注释：

```python
type_to_ignore = "something" # type: ignore
```

重要的是要注意，为了使这个工具或任何工具有用，我们必须小心我们在代码中声明的类型注释。 如果我们对类型集过于通用，我们可能会错过一些工具可以报告合法问题的情况。

在以下示例中，有一个函数旨在接收要迭代的参数。 最初，任何可迭代对象都可以工作，因此我们希望利用 Python 的动态类型功能，并允许一个函数可以使用传递列表、元组、字典键、集合或几乎任何支持 for 循环的东西：

```python
def broadcast_notification(
    message: str, 
    relevant_user_emails: Iterable[str]
):
    for email in relevant_user_emails:
        logger.info("Sending %r to %r", message, email)
```

问题是如果代码的某些部分错误地传递了这些参数，mypy就不会报错：

```python
broadcast_notification("welcome", "user1@domain.com")
```

当然，这不是一个有效的实例，因为它会迭代字符串中的每个字符，并尝试将其用作电子邮件。

相反，如果我们对该参数设置的类型更加严格（假设只接受字符串列表或元组），那么运行 mypy 确实可以识别这种错误情况：

```bash
$ mypy <file-name>
error: Argument 2 to "broadcast_notification" has incompatible type "str"; expected "Union[List[str], Tuple[str]]"
```

同样，pytype 也是可配置的并且以类似的方式工作，因此您可以根据项目的特定上下文调整这两种工具。 我们可以看到这个工具报告的错误与之前的情况非常相似：

```python
File "...", line 22, in <module>: Function broadcast_notification was called with the wrong arguments [wrong-arg-types]
         Expected: (message, relevant_user_emails: Union[List[str], Tuple[str]])
  Actually passed: (message, relevant_user_emails: str)
```

pytype 的一个主要区别是，它不仅会根据参数检查定义，还会尝试解释运行时的代码是否正确，并报告运行时错误。 例如，如果暂时违反了其中一个类型定义，只要最终结果符合声明的类型，就不会将其视为问题。 虽然这是一个很好的特性，但总的来说，我建议您尽量不要破坏您在代码中设置的不变量，并尽可能避免中间无效状态，因为这将使您的代码更容易推理和依赖更少 副作用。

### 代码中的通用验证

除了使用上一节中介绍的工具来检查程序类型管理中的错误之外，我们还可以使用其他工具来提供针对更广泛参数的验证。

Python中有很多用于检查代码结构的工具（基本上，这是符合PEP-8的），例如pycodestyle（以前在PyPi中称为pep8），flake8等等。它们都是可配置的，并且就像运行它们提供的命令一样易于使用。

这些工具是运行在一组 Python 文件上的程序，并根据 PEP-8 标准检查代码的合规性，报告违反的每一行以及违反规则的指示性错误。

还有其他工具可以提供更完整的检查，因此不仅仅是验证是否符合 PEP-8，它们还包括对超过 PEP-8 的更复杂情况的额外检查（请记住，代码仍然可以完全符合 PEP-8 和仍然不是很好的质量）。

例如，PEP-8 主要是关于样式化和结构化我们的代码，但它并不强制我们在每个公共方法、类或模块上放置一个文档字符串。它也没有说明带有太多参数的函数（我们将在本书后面将其识别为不良特征）。

这种工具的一个例子是 pylint。这是用于验证 Python 项目的最完整和最严格的工具之一，并且它也是可配置的。和以前一样，要使用它，你只需要在虚拟环境中使用 pip 安装它：

```bash
$ pip install pylint
```

然后，只需运行 pylint 命令就足以在代码中检查它。

可以通过名为 pylintrc 的配置文件来配置 pylint。 在此文件中，您可以决定要启用或禁用的规则，并参数化其他规则（例如，更改列的最大长度）。 例如，正如我们刚刚讨论的，我们可能不希望每个函数都有一个文档字符串，因为强制这样做可能会适得其反。 然而，默认情况下，pylint 会施加这个限制，但我们可以通过在配置文件中声明它来否决它：

```ini
[DESIGN]
disable=missing-function-docstring
```

一旦这个配置文件达到稳定状态（意味着它符合编码指南并且不需要进一步调整），然后它可以被复制到其余的存储库，它也应该在版本控制之下。

>  记录开发团队同意的编码标准，然后在存储库中自动运行的工具的配置文件中强制执行它们。

最后，还有一个我想提一下的工具，那就是 Coala (https://github.com/coala/coala)。 Coala 更通用一些（意味着它支持多种语言，而不仅仅是 Python），但其思想与之前的类似：它需要一个配置文件，然后它提供了一个命令行工具，该工具将对代码。运行时，如果该工具在扫描文件时检测到一些错误，它可能会提示用户有关这些错误，并会在适用时建议自动应用修复补丁。

但是，如果我有一个工具的默认规则未涵盖的用例怎么办？ pylint 和 Coala 都附带了许多涵盖最常见场景的预定义规则，但您可能仍会在您的组织中检测到一些导致错误的模式。

如果您在代码中检测到容易出错的重复模式，我建议您花一些时间来定义您自己的规则。这两个工具都是可扩展的：在 pylint 的情况下，有多个插件可用，您可以编写自己的插件。对于 Coala，您可以编写自己的验证模块，与常规检查一起运行。

### 自动格式化

正如本章开头所提到的，明智的做法是让团队就代码的编写约定达成一致，避免讨论个人对拉取请求的偏好，并专注于代码的本质。但协议只能让你走这么远，如果不执行这些规则，它们会随着时间的推移而消失。

除了通过工具检查是否符合标准外，直接自动格式化代码也很有用。

有多种工具可以自动格式化 Python 代码（例如，大多数验证 PEP-8 的工具，如 flake8，也具有重写代码并使其符合 PEP-8 的模式），并且它们也是可配置的和适应每个特定项目。其中，也许是因为完全灵活性和配置的反面，我想强调的是：黑色。

black (https://github.com/psf/black) 有一个特殊性，它以独特且确定性的方式格式化代码，不允许任何参数（可能除了行的长度）。

一个例子是 black 将始终使用双引号格式化字符串，并且参数的顺序将始终遵循相同的结构。这听起来可能很严格，但这是确保代码差异最小化的唯一方法。如果代码始终遵循相同的结构，则代码中的更改只会显示在带有实际更改的拉取请求中，而不会进行额外的外观修改。它比 PEP-8 限制更多，但也很方便，因为通过直接通过工具格式化代码，我们实际上不必担心，我们可以专注于手头问题的症结。

这也是黑色存在的原因。 PEP-8 定义了一些指导来构建我们的代码，但是有多种方法可以让代码符合 PEP-8，所以仍然存在寻找风格差异的问题。黑色格式代码的方式是将其移动到 PEP-8 的更严格的子集，该子集始终是确定性的。

例如，请参阅以下代码符合 PEP-8，但不遵循黑色约定：

```python
def my_function(name):
    """
    >>> my_function('black')
    'received Black'
    """
    return 'received {0}'.format(name.title())
```

现在，我们可以运行以下命令来格式化文件：

```python
black -l 79 *.py
```

我们可以看到该工具写了什么：

```python
def my_function(name):
    """
    >>> my_function('black')
    'received Black'
    """
    return "received {0}".format(name.title())
```

在更复杂的代码上，会有更多的变化（尾随逗号等），但可以清楚地看到这个想法。同样，这是固执己见，但拥有一个为我们处理细节的工具也是一个好主意。

这也是 Golang 社区很久以前学到的东西，以至于有一个标准的工具库 go fmt，可以根据语言的约定自动格式化代码。 Python现在有这样的东西很好。

安装后，默认情况下，'black' 命令将尝试格式化代码，但它也有一个 '--check' 选项，该选项将根据标准验证文件，如果未通过验证。此命令非常适合作为自动检查和 CI 流程的一部分使用。

值得一提的是，black 将彻底格式化文件，并且它不支持部分格式化（与其他工具相反）。对于已经具有不同风格代码的遗留项目，这可能是一个问题，因为如果您想在项目中采用黑色作为格式标准，您很可能必须接受以下两种情况之一：

1. 创建一个里程碑拉取请求，将黑色格式应用于存储库中的所有 Python 文件。这样做的缺点是会增加大量噪音并污染 repo 的版本控制历史记录。在某些情况下，您的团队可能会决定接受风险（取决于您对 git 历史记录的依赖程度）。
2. 或者，您可以使用应用黑色格式的代码更改重写历史记录。在 git 中，可以通过在每次提交上应用一些命令来重写提交（从一开始）。在这种情况下，我们可以在应用“黑色”格式后重写每个提交。最后，看起来该项目从一开始就处于新形式，但有一些注意事项。首先，项目的历史被重写，所以每个人都必须刷新他们的存储库的本地副本。其次，根据存储库的历史记录，如果有很多提交，这个过程可能需要一段时间。

如果不接受以“全有或全无”方式进行格式化，我们可以使用 yapf (https://github.com/google/yapf)，这是另一个与黑色有许多不同之处的工具：它是高度可定制，并且它还接受部分格式（仅将格式应用于文件的某些区域）。

yapf 接受一个参数来指定要应用格式的行的范围。有了这个，您可以配置您的编辑器或 IDE（或者更好的是，设置一个 git pre-commit 钩子），以仅在刚刚更改的代码区域上自动格式化代码。通过这种方式，项目可以在进行更改时分阶段与编码标准保持一致。

总结一下自动格式化代码的工具部分，我们可以说 black 是一个很棒的工具，可以将代码推向规范标准，因此，您应该尝试在您的存储库中使用它。在创建的新存储库上使用黑色绝对没有摩擦，但也可以理解，对于遗留存储库，这可能会成为一个障碍。如果团队认为在遗留存储库中采用黑色太麻烦，那么 yapf 之类的工具可能更合适。

### 设置自动检查

在 Unix 开发环境中，最常见的工作方式是通过 Makefile。 Makefile 是强大的工具，可以让我们配置要在项目中运行的命令，主要用于编译、运行等。 除此之外，我们可以在项目的根目录中使用 Makefile，并配置一些命令来自动检查代码的格式和约定。

一个很好的方法是为测试和每个特定测试设置目标，然后让另一个完全运行； 例如：

```ini
.PHONY: typehint
typehint:
	mypy --ignore-missing-imports src/
.PHONY: test
test:
	pytest tests/
.PHONY: lint
lint:
	pylint src/
.PHONY: checklist
checklist: lint typehint test
.PHONY: black
black:
	black -l 79 *.py
.PHONY: clean
clean:
	find . -type f -name "*.pyc" | xargs rm -fr
	find . -type d -name __pycache__ | xargs rm -fr
```

在这里，我们运行的命令（在我们的开发机器和 CI 环境构建上）如下：

```
make checklist
```

这将按以下步骤运行所有内容：

1. 它将首先检查是否符合编码指南（例如，PEP-8 或带有“--check”参数的黑色）。
2. 然后它将检查代码中类型的使用。
3. 最后，它将运行测试。

如果这些步骤中的任何一个失败，则将整个过程视为失败。

这些工具（black、pylint、mypy 等）可以与您选择的编辑器或 IDE 集成，使事情变得更加容易。将编辑器配置为在保存文件时或通过快捷方式进行此类修改是一项不错的投资。

值得一提的是，Makefile 的使用有以下几个原因：首先，有一种简单的方法可以自动执行最重复的任务。团队的新成员可以通过了解诸如“make format”之类的东西自动格式化代码，而不管使用的底层工具（及其参数）如何，从而快速上手。此外，如果后来决定更改工具（假设您要从 yapf 切换到黑色），那么相同的命令（'make format'）仍然有效。

其次，尽可能多地利用 Makefile 是件好事，这意味着将 CI 工具配置为也调用 Makefile 中的命令。这样就有了在项目中运行主要任务的标准化方式，并且我们在 CI 工具中放置尽可能少的配置（同样，将来可能会发生变化，这不必成为主要负担） .

## 总结

我们现在对什么是整洁的代码有了初步的了解，并对它进行了可行的解释，这将作为本书其余部分的参考点。

更重要的是，我们现在明白整洁的代码比代码的结构和布局更重要。我们必须关注想法在代码中是如何表示的，以查看它们是否正确。整洁的代码是关于代码的可读性、可维护性，将技术债务保持在最低限度，并在代码中有效地传达我们的想法，以便其他人可以首先理解我们打算编写的内容。

但是，我们讨论过，出于多种原因，遵守编码风格或指南很重要。我们同意这是一个必要条件，但不是充分条件，而且由于这是每个可靠项目都应遵守的最低要求，很明显，我们最好将其留给工具。因此，自动化所有这些检查变得至关重要，在这方面，我们必须牢记如何配置 mypy、pylint、black 等工具。

下一章将更加关注 Python 特定的代码，以及如何用惯用的 Python 表达我们的想法。我们将探索 Python 中使代码更紧凑和高效的习惯用法。在这个分析中，我们将看到，总的来说，Python 与其他语言相比，有不同的想法或不同的方法来完成任务。

## 参考

PEP-8：https://www.python.org/dev/peps/pep-0008/
我的：http://mypy-lang.org/
pytype：https://google.github.io/pytype/
PEP-3107：https://www.python.org/dev/peps/pep-3107/
PEP-484：https://www.python.org/dev/peps/pep-0484/
PEP-526：https://www.python.org/dev/peps/pep-0526/
PEP-557：https://www.python.org/dev/peps/pep-0557/
PEP-585：https://www.python.org/dev/peps/pep-0585/