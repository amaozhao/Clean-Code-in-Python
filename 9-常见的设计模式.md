设计模式自著名的四人组 (GoF) 一书《设计模式：可重用面向对象软件的元素》中首次提出以来，一直是软件工程中的一个普遍话题。设计模式有助于通过适用于某些场景的抽象来解决常见问题。当它们被正确实施时，解决方案的总体设计可以从中受益。

在本章中，我们将研究一些最常见的设计模式，但不是从在特定条件下（一旦设计出模式后）应用的工具的角度来看，而是分析设计模式如何有助于清洁代码。在介绍了实现设计模式的解决方案之后，我们将分析最终实现如何比我们选择不同的路径更好。

作为分析的一部分，我们将看到如何在 Python 中具体实现设计模式。因此，我们将看到 Python 的动态特性意味着实现与其他静态类型语言的一些差异，许多设计模式最初是针对这些静态类型语言考虑的。这意味着当涉及到 Python 时，您应该牢记设计模式的一些特殊性，并且在某些情况下，尝试应用它并不真正适合的设计模式是非 Pythonic 的。

在本章中，我们将涵盖以下主题：

- 常见的设计模式
- 不适用于 Python 的设计模式，以及应遵循的惯用替代方案
- 实现最常见设计模式的 Pythonic 方式
- 理解好的抽象如何自然演变成模式

有了前几章的知识，我们现在可以在更高的设计层次上分析代码，同时考虑它的详细实现（我们将如何以使用 Python 特性的方式编写它？最有效？）。

在本章中，我们将分析如何使用设计模式来实现更简洁的代码，首先分析下一节中的一些初步注意事项。

## Python 中的设计模式注意事项

面向对象的设计模式是当我们处理我们正在解决的问题的模型时出现在不同场景中的软件构造思想。因为它们是高级思想，所以很难将它们视为与特定的编程语言相关联。相反，它们是关于对象如何在应用程序中交互的更一般的概念。当然，它们的实现细节会因语言而异，但这并不构成设计模式的本质。

这是设计模式的理论方面，事实上它是一个抽象的想法，表达了有关解决方案中对象布局的概念。关于面向对象设计，特别是设计模式，还有很多其他书籍和其他资源，因此在本书中，我们将重点关注 Python 的实现细节。

鉴于 Python 的性质，实际上并不需要一些经典的设计模式。这意味着 Python 已经支持使这些模式不可见的功能。有些人认为它们在 Python 中不存在，但请记住，不可见并不意味着不存在。它们就在那里，只是嵌入在 Python 本身中，因此我们可能甚至不会注意到它们。

其他的实现要简单得多，这再次归功于语言的动态特性，其余的实际上与其他平台中的相同，只有很小的差异。

无论如何，在 Python 中实现干净代码的重要目标是知道要实现什么模式以及如何实现。这意味着识别 Python 已经抽象的一些模式以及我们如何利用它们。例如，尝试实现迭代器模式的标准定义（就像我们在不同的语言中所做的那样）将是完全非 Pythonic 的，因为（正如我们已经介绍过的）迭代深深地嵌入在 Python 中，并且事实上我们可以创建直接在 for 循环中工作的对象，这使得这是继续进行的正确方式。

一些创建模式也会发生类似的事情。类是 Python 中的常规对象，函数也是。正如我们目前在几个例子中看到的，它们可以被传递、修饰、重新分配等等。这意味着无论我们想对我们的对象进行何种类型的定制，我们很可能不需要任何特定的工厂类设置就可以做到。此外，在 Python 中没有用于创建对象的特殊语法（例如，没有 new 关键字）。这也是为什么在大多数情况下，简单的函数调用会像工厂一样工作的另一个原因。

仍然需要其他模式，我们将看到如何通过一些小的调整，使它们更加 Pythonic，充分利用该语言提供的功能（魔术方法或标准库）。

在所有可用的模式中，并非所有模式都同样频繁或有用，因此我们将重点关注主要模式，即我们希望在我们的应用程序中看到最多的模式，我们将遵循务实的方法来做到这一点.

## 实践中的设计模式

该主题中的规范参考由 GoF 编写，介绍了 23 种设计模式，每一种都属于创建、结构和行为类别之一。现有模式还有更多模式或变体，但与其背诵所有这些模式，我们还应该专注于牢记两件事。有些模式在 Python 中是不可见的，我们可能甚至没有注意到它们。其次，并非所有模式都同样常见；其中一些非常有用，因此经常被发现，而另一些则用于更具体的情况。

在本节中，我们将重新审视最常见的模式，即最有可能从我们的设计中出现的模式。注意这里使用了emerge这个词。我们不应该强制将设计模式应用到我们正在构建的解决方案中，而是应该进化、重构和改进我们的解决方案，直到出现一个模式。

因此，设计模式不是发明出来的，而是发现的。当我们的代码中反复出现的情况暴露出来时，类、对象和相关组件的一般和更抽象的布局会出现在我们识别模式的名称下。

设计模式的名称包含了很多概念。这可能是关于设计模式的最好的事情；他们提供了一种语言。通过设计模式，更容易有效地传达设计思想。当两个或多个软件工程师共享相同的词汇时，其中一个提到了策略，房间里的其他软件工程师可以立即考虑所有的类，以及它们之间的关系，它们的机制是什么等等上，无需重复此解释。

读者会注意到本章中显示的代码与所讨论的设计模式的规范或原始设想不同。造成这种情况的原因不止一个。第一个原因是示例采取了更务实的方法，针对特定场景的解决方案，而不是探索通用设计理论。第二个原因是模式是根据 Python 的特殊性实现的，在某些情况下非常微妙，但在其他情况下，差异很明显，通常可以简化代码。

### 创建者模式

在软件工程中，创建模式是那些处理对象实例化的模式，试图抽象掉大部分复杂性（例如确定初始化对象的参数、可能需要的所有相关对象等），以便离开用户界面更简单，使用起来更安全。对象创建的基本形式可能会导致设计问题或增加设计的复杂性。创建型设计模式通过以某种方式控制此对象创建来解决此问题。

在创建对象的五种模式中，我们将主要讨论用于避免单例模式并将其替换为 Borg 模式（最常用于 Python 应用程序）的变体，讨论它们的区别和优点。

#### 工厂

正如介绍中提到的，Python 的核心特性之一是一切都是对象，因此，它们都可以被平等对待。这意味着对于我们可以或不能对类、函数或自定义对象执行的操作没有特殊区别。它们都可以通过参数传递、分配等。

正是由于这个原因，通常不需要许多工厂模式。我们可以简单地定义一个函数来构造一组对象，我们甚至可以使用参数传递我们想要创建的类。

当我们使用 pyinject 作为一个库来帮助我们进行依赖注入和复杂对象的初始化时，我们看到了一个工厂的例子。如果我们需要处理复杂的设置，并且希望确保我们使用依赖注入来初始化我们的对象而不重复我们自己，我们可以使用诸如 pyinject 之类的库或在我们的代码中提出类似的结构。

#### 单例和共享状态（monostate）

另一方面，单例模式并不是 Python 完全抽象的东西。事实是，大多数情况下，这种模式要么不是真的需要，要么是一个糟糕的选择。单例有很多问题（毕竟，它们实际上是面向对象软件的一种全局变量形式，因此是一种不好的做法）。它们很难进行单元测试，它们可能随时被任何对象修改的事实使它们难以预测，并且它们的副作用可能真的很成问题。

作为一般原则，我们应该尽可能避免使用单例。如果在某些极端情况下需要它们，那么在 Python 中实现这一点的最简单方法是使用模块。我们可以在模块中创建一个对象，一旦它在那里，它就可以从导入的模块的每个部分中获得。 Python 本身确保模块已经是单例的，从某种意义上说，无论它们被导入多少次，从多少地方导入，同一个模块始终是要加载到 sys.modules 的模块。因此，在此 Python 模块内初始化的对象将是唯一的。

请注意，这与单例并不完全相同。单例的想法是创建一个类，无论您调用它多少次，都将始终为您提供相同的对象。上一段中提出的想法是关于拥有一个独特的对象。不管它的类是如何定义的，我们只创建一次对象，然后多次使用同一个对象。这些有时被称为众所周知的对象；不需要多于一种的对象。

我们已经熟悉这些对象。考虑无。对于整个 Python 解释器，我们不需要多个。一些开发人员声称“在 Python 中 None 是单例”。我有点不同意这一点。这是一个众所周知的对象：我们都知道的东西，我们不需要另一个。 True 和 False 也是如此。尝试创建不同类型的布尔值是没有意义的。

#### 共享状态

与其强迫我们的设计有一个只创建一个实例的单例，无论对象如何调用、构造或初始化，最好跨多个实例复制数据。

单态模式 (SNGMONO) 的想法是我们可以拥有许多只是常规对象的实例，而不必关心它们是否是单例（因为它们只是对象）。这种模式的好处是这些对象将以完全透明的方式同步它们的信息，而我们不必担心它在内部是如何工作的。

这使得这种模式成为更好的选择，不仅是因为它的方便，而且因为它不容易出错，并且受单例的不利影响更少（关于它们的可测试性、创建派生类等）。

我们可以在很多层面上使用这种模式，这取决于我们需要同步多少信息。

以最简单的形式，我们可以假设我们只需要一个属性来反映所有实例。如果是这种情况，实现就像使用类变量一样简单，我们只需要提供一个正确的接口来更新和检索属性的值。

假设我们有一个对象，它必须通过 latest 标签在 Git 存储库中提取某些代码的版本。这个对象可能有多个实例，当每个客户端调用获取代码的方法时，这个对象将使用其属性中的标签版本。在任何时候，这个标签都可以更新为更新的版本，我们希望任何其他实例（新的或已经创建的）在调用 fetch 操作时使用这个新分支，如以下代码所示：

```python
class GitFetcher:
    _current_tag = None
    def __init__(self, tag):
        self.current_tag = tag
    @property
    def current_tag(self):
        if self._current_tag is None:
            raise AttributeError("tag was never set")
        return self._current_tag
    @current_tag.setter
    def current_tag(self, new_tag):
        self.__class__._current_tag = new_tag
    def pull(self):
        logger.info("pulling from %s", self.current_tag)
        return self.current_tag
```

读者可以简单地验证，创建多个不同版本的 GitFetcher 类型的对象会导致所有对象随时都设置为最新版本，如下代码所示：

```python
>>> f1 = GitFetcher(0.1)
>>> f2 = GitFetcher(0.2)
>>> f1.current_tag = 0.3
>>> f2.pull()
0.3
>>> f1.pull()
0.3
```

如果我们需要更多属性，或者我们希望更多地封装共享属性，为了使设计更简洁，我们可以使用描述符。

一个descriptor，就像下面代码中的那个，解决了这个问题，虽然确实需要更多的代码，但是它也封装了一个更具体的职责，部分代码实际上从我们原来的类中移开了，使得它 更具凝聚力并符合单一职责原则：

```python
class SharedAttribute:
    def __init__(self, initial_value=None):
        self.value = initial_value
        self._name = None
    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.value is None:
            raise AttributeError(f"{self._name} was never set")
        return self.value
    def __set__(self, instance, new_value):
        self.value = new_value
    def __set_name__(self, owner, name):
        self._name = name
```

除了这些考虑因素之外，该模式现在更具可重用性也是事实。 如果我们想重复这个逻辑，我们只需要创建一个新的描述符对象，它可以工作（符合 DRY 原则）。

如果我们现在想要为当前分支做同样的事情，我们创建这个新的类属性，类的其余部分保持不变，同时仍然具有所需的逻辑，如以下代码所示：

```python
class GitFetcher:
    current_tag = SharedAttribute()
    current_branch = SharedAttribute()
    def __init__(self, tag, branch=None):
        self.current_tag = tag
        self.current_branch = branch
    def pull(self):
        logger.info("pulling from %s", self.current_tag)
        return self.current_tag
```

这种新方法的平衡和权衡现在应该很清楚了。这个新实现使用了更多的代码，但它是可重用的，因此从长远来看，它可以节省代码行（和重复的逻辑）。再次参考三个或更多实例规则来决定是否应该创建这样的抽象。

这个解决方案的另一个重要好处是它还减少了单元测试的重复（因为我们只需要测试 SharedAttribute 类，而不是它的所有用途）。

在这里重用代码会让我们对解决方案的整体质量更有信心，因为现在我们只需要为描述符对象编写单元测试，而不是为所有使用它的类（我们可以安全地假设它们是正确的，只要因为单元测试证明描述符是正确的）。

#### 博格模式

以前的解决方案应该适用于大多数情况，但如果我们真的必须使用单例（这必须是一个非常好的例外），那么还有最后一个更好的替代方案，只是这是一个风险更大的方案。

这是实际的单态模式，在 Python 中称为 Borg 模式。这个想法是创建一个对象，该对象能够在同一类的所有实例之间复制其所有属性。绝对每个属性都被复制的事实必须是一个警告，记住不想要的副作用。尽管如此，这种模式比单例有很多优点。

在这种情况下，我们将把前面的对象分成两个——一个在 Git 标签上工作，另一个在分支上工作。我们正在使用使 Borg 模式工作的代码：

```python
class BaseFetcher:
    def __init__(self, source):
        self.source = source
class TagFetcher(BaseFetcher):
    _attributes = {}
    def __init__(self, source):
        self.__dict__ = self.__class__._attributes
        super().__init__(source)
    def pull(self):
        logger.info("pulling from tag %s", self.source)
        return f"Tag = {self.source}"
class BranchFetcher(BaseFetcher):
    _attributes = {}
    def __init__(self, source):
        self.__dict__ = self.__class__._attributes
        super().__init__(source)
    def pull(self):
        logger.info("pulling from branch %s", self.source)
        return f"Branch = {self.source}"
```

两个对象都有一个基类，共享它们的初始化方法。但是他们必须再次实现它才能使 Borg 逻辑工作。这个想法是我们使用一个作为字典的类属性来存储属性，然后我们让每个对象的字典（在它被初始化时）使用这个完全相同的字典。这意味着对对象字典的任何更新都将反映在类中，其余对象的情况也是如此，因为它们的类是相同的，而字典是作为引用传递的可变对象。换句话说，当我们创建这种类型的新对象时，它们都会使用同一个字典，并且这个字典是不断更新的。

注意我们不能把字典的逻辑放在基类上，因为这样会混淆不同类的对象之间的值，这不是我们想要的。这种样板解决方案会让许多人认为它实际上是一种习语，而不是一种模式。

以实现 DRY 原则的方式抽象它的一种可能方法是创建一个 mixin 类，如以下代码所示：

```python
class SharedAllMixin:
    def __init__(self, *args, **kwargs):
        try:
            self.__class__._attributes
        except AttributeError:
            self.__class__._attributes = {}
        self.__dict__ = self.__class__._attributes
        super().__init__(*args, **kwargs)
class BaseFetcher:
    def __init__(self, source):
        self.source = source
class TagFetcher(SharedAllMixin, BaseFetcher):
    def pull(self):
        logger.info("pulling from tag %s", self.source)
        return f"Tag = {self.source}"
class BranchFetcher(SharedAllMixin, BaseFetcher):
    def pull(self):
        logger.info("pulling from branch %s", self.source)
        return f"Branch = {self.source}"
```

这一次，我们使用 mixin 类创建字典，其中包含每个类中的属性，以防它不存在，然后继续使用相同的逻辑。

这个实现在继承方面不应该有任何重大问题，所以它是一个更可行的替代方案。

#### 建造者

构建器模式是一个有趣的模式，它抽象了对象的所有复杂初始化。这种模式不依赖于语言的任何特殊性，因此它在 Python 中与在任何其他语言中一样适用。

虽然它解决了一个有效的案例，但它通常也是一个复杂的案例，更有可能出现在框架、库或 API 的设计中。类似于为描述符给出的建议，我们应该为我们期望公开一个将由多个用户使用的 API 的情况保留此实现。

这种模式的高级思想是，我们需要创建一个复杂的对象，即一个还需要许多其他对象来处理的对象。与其让用户创建所有这些辅助对象，然后将它们分配给主要对象，不如创建一个抽象，让所有这些都可以在一个步骤中完成。为了实现这一点，我们将有一个构建器对象，它知道如何创建所有部分并将它们链接在一起，为用户提供一个接口（可以是一个类方法）来参数化有关结果对象应该是什么样子的所有信息喜欢。

### 结构模式

结构模式对于我们需要创建更简单的接口或通过扩展其功能而不增加其接口复杂性而更强大的对象的情况很有用。

这些模式的最大优点是我们可以创建更多有趣的对象，并具有增强的功能，并且我们可以以一种干净的方式实现这一点；也就是说，通过组合多个单个对象（最明显的例子是复合模式），或者通过收集许多简单且有凝聚力的接口。

#### 适配器

适配器模式可能是最简单的设计模式之一，同时也是最有用的模式之一。

这种模式也称为包装器，解决了适配两个或多个不兼容对象的接口的问题。

我们通常会遇到这样一种情况：我们的部分代码与一个模型或一组相对于方法多态的类一起工作。例如，如果有多个使用 fetch() 方法检索数据的对象，那么我们希望维护这个接口，这样我们就不必对我们的代码进行重大更改。

但是后来我们需要添加一个新的数据源，唉，这个数据源没有 fetch() 方法。更糟糕的是，这种类型的对象不仅不兼容，而且也不是我们可以控制的（可能是不同的团队决定了 API，我们无法修改代码，或者它是来自外部库的对象） ）。

我们不是直接使用这个对象，而是将它的接口调整为我们需要的接口。有两种方法可以做到这一点。

第一种方法是创建一个继承自我们需要的类并为该方法创建别名（如果需要，它还必须调整参数和签名），这将在内部调整调用以使其兼容用我们需要的方法。

通过继承，我们导入外部类并创建一个定义新方法的新类，调用具有不同名称的方法。在这个例子中，假设外部依赖有一个名为 search() 的方法，它只接受一个参数进行搜索，因为它以不同的方式查询，所以我们的适配器方法不仅调用外部依赖，而且还翻译参数相应地，如以下代码所示：

```python
from _adapter_base import UsernameLookup
class UserSource(UsernameLookup):
    def fetch(self, user_id, username):
        user_namespace = self._adapt_arguments(user_id, username)
        return self.search(user_namespace)
    @staticmethod
    def _adapt_arguments(user_id, username):
        return f"{user_id}:{username}"
```

利用 Python 支持多重继承这一事实，我们可以使用它来创建我们的适配器（甚至创建一个作为适配器的 mixin 类，正如我们在前几章中看到的那样）。

然而，正如我们之前多次看到的，继承带来了更多的耦合（谁知道从外部库中携带了多少其他方法？），而且它是不灵活的。 从概念上讲，这也不是正确的选择，因为我们为规范的情况保留继承（继承是一种关系），在这种情况下，我们的对象必须是其中一种完全不清楚 由第三方库提供的（特别是因为我们不完全理解该对象）。

因此，更好的方法是改用组合。 假设我们可以为我们的对象提供 UsernameLookup 的实例，代码将就像在采用参数之前重定向请求一样简单，如下面的代码所示：

```python
class UserSource:
    ...
    def fetch(self, user_id, username):
        user_namespace = self._adapt_arguments(user_id, username)
        return self.username_lookup.search(user_namespace)
```

如果我们需要适应多个方法，并且我们也可以设计一种通用的方法来适应它们的签名，那么使用 \_\_getattr\_\_() 魔术方法将请求重定向到被包装的对象可能是值得的，但与通用实现一样，我们应该注意不要给解决方案增加更多的复杂性。

\_\_getattr\_\_() 的使用可能使我们拥有一种“通用适配器”；可以包装另一个对象并通过以通用方式重定向调用来适应其所有方法的东西。但是我们真的应该小心这个，因为这种方法会创建一些非常通用的东西，它可能会更具风险并且会产生意想不到的副作用。如果我们想对一个对象执行转换或额外的功能，同时保持它的原始界面，装饰器模式是一个更好的选择，我们将在本章后面看到。

#### 合成

我们程序的某些部分需要我们使用由其他对象组成的对象。我们有具有明确定义的逻辑的基础对象，然后我们将有其他容器对象将一堆基础对象分组，挑战在于我们想要在不注意的情况下处理它们（基础对象和容器对象）任何差异。

对象在树层次结构中构建，其中基本对象是树的叶子，组合对象是中间节点。客户端可能想要调用其中任何一个来获取被调用方法的结果。然而，复合对象将充当客户端；这也将传递此请求及其包含的所有对象，无论它们是叶子还是其他中间音符，直到它们全部处理完毕。

想象一下我们有产品的在线商店的简化版本。假设我们提供对这些产品进行分组的可能性，并且我们为客户提供每组产品的折扣。一个产品有一个价格，当顾客来付款时，这个价值会被要求。但是一组分组的产品也有一个必须计算的价格。我们将有一个对象代表包含产品的这个组，并将询问价格的责任委托给每个特定产品（也可能是另一组产品），依此类推，直到没有其他东西需要计算.

其实现如以下代码所示：

```python
class Product:
    def __init__(self, name: str, price: float) -> None:
        self._name = name
        self._price = price
    @property
    def price(self):
        return self._price
class ProductBundle:
    def __init__(
        self,
        name: str,
        perc_discount: float,
        *products: Iterable[Union[Product, "ProductBundle"]]
    ) -> None:
        self._name = name
        self._perc_discount = perc_discount
        self._products = products
    @property
    def price(self) -> float:
        total = sum(p.price for p in self._products)
        return total * (1 - self._perc_discount)
```

我们通过属性公开公共接口，并将价格保留为私有属性。 ProductBundle 类使用此属性通过首先将其包含的所有产品的所有价格相加来计算应用了折扣的值。

这些对象之间的唯一差异是它们是使用不同的参数创建的。为了完全兼容，我们应该尝试模仿相同的接口，然后添加额外的方法来将产品添加到捆绑包中，但使用允许创建完整对象的接口。不需要这些额外的步骤是证明这种微小差异的一个优势。

#### 装饰器

不要将装饰器模式与 Python 装饰器的概念混淆，我们在第 5 章使用装饰器改进我们的代码中已经讨论过。有一些相似之处，但设计模式的想法却大不相同。

这种模式允许我们动态扩展某些对象的功能，而无需继承。在创建更灵活的对象时，它是多重继承的一个很好的替代方案。

我们将创建一个结构，让用户定义一组要应用于对象的操作（装饰），我们将看到每个步骤如何以指定的顺序发生。

下面的代码示例是一个对象的简化版本，该对象根据传递给它的参数以字典的形式构造查询（例如，它可能是我们用于运行对 Elasticsearch 的查询的对象，但代码省略了分散注意力的实现细节，专注于模式的概念）。

在最基本的形式中，查询只返回字典以及它在创建时提供的数据。客户端希望使用这个对象的 render() 方法：

```python
class DictQuery:
    def __init__(self, **kwargs):
        self._raw_query = kwargs
    def render(self) -> dict:
        return self._raw_query
```

现在我们希望通过对数据应用转换（过滤值、规范化它们等）以不同的方式呈现查询。 我们可以创建装饰器并将它们应用到 render 方法，但这不够灵活——如果我们想在运行时更改它们怎么办？ 或者如果我们想选择其中的一些，而不是其他的？

设计是创建另一个对象，具有相同的界面和通过许多步骤增强（装饰）原始结果的能力，但可以组合。 这些对象被链接起来，每个对象都做它最初应该做的事情，再加上其他的东西。 这就是特定的装饰步骤。

由于 Python 具有鸭子类型，因此我们不需要创建新的基类并使这些新对象与 DictQuery 一起成为该层次结构的一部分。 只需创建一个具有 render() 方法的新类就足够了（同样，多态不应该需要继承）。 此过程显示在以下代码中：

```python
class QueryEnhancer:
    def __init__(self, query: DictQuery):
        self.decorated = query
    def render(self):
        return self.decorated.render()
class RemoveEmpty(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v for k, v in original.items() if v}
class CaseInsensitive(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v.lower() for k, v in original.items()}
```

QueryEnhancer 短语具有与 DictQuery 客户端所期望的兼容的接口，因此它们是可互换的。 此对象旨在接收装饰的对象。 它将从中获取值并转换它们，返回代码的修改版本。

如果我们想删除所有评估为 False 的值并将它们规范化以形成我们的原始查询，我们必须使用以下模式：

```python
>>> original = DictQuery(key="value", empty="", none=None, upper="UPPERCASE", title="Title")
>>> new_query = CaseInsensitive(RemoveEmpty(original))
>>> original.render()
{'key': 'value', 'empty': '', 'none': None, 'upper': 'UPPERCASE', 'title': 'Title'}
>>> new_query.render()
{'key': 'value', 'upper': 'uppercase', 'title': 'title'}
```

这是一种我们也可以通过不同方式实现的模式，利用 Python 的动态特性，以及函数是对象的事实。 我们可以使用提供给基本装饰器对象 (QueryEnhancer) 的函数来实现此模式，并将每个装饰步骤定义为一个函数，如以下代码所示：

```python
class QueryEnhancer:
    def __init__(
        self,
        query: DictQuery,
        *decorators: Iterable[Callable[[Dict[str, str]], Dict[str, str]]]
    ) -> None:
        self._decorated = query
        self._decorators = decorators
    def render(self):
        current_result = self._decorated.render()
        for deco in self._decorators:
            current_result = deco(current_result)
        return current_result
```

对于客户端，没有任何变化，因为此类通过其 render() 方法保持兼容性。 但是，在内部，此对象的使用方式略有不同，如以下代码所示：

```python
>>> query = DictQuery(foo="bar", empty="", none=None, upper="UPPERCASE", title="Title")
>>> QueryEnhancer(query, remove_empty, case_insensitive).render()
{'foo': 'bar', 'upper': 'uppercase', 'title': 'title'}
```

在前面的代码中，remove_empty 和 case_insensitive 只是转换字典的常规函数。

在这个例子中，基于函数的方法似乎更容易理解。可能有更复杂的规则依赖于被装饰对象的数据（不仅是它的结果）的情况，在这些情况下，面向对象的方法可能是值得的，特别是如果我们真的想创建一个层次结构其中每个类实际上代表了一些我们希望在设计中明确的知识。

#### 门面

Facade 是一个很好的模式。它在我们想要简化对象之间的交互的许多情况下很有用。该模式适用于多个对象之间存在多对多关系的情况，并且我们希望它们进行交互。我们没有创建所有这些连接，而是在其中许多作为外观的连接之前放置一个中间对象。

立面在此布局中用作枢纽或单一参考点。每当一个新对象想要连接到另一个对象时，它不需要为它需要连接的所有 N 个可能的对象拥有 N 个接口（需要 O(N2) 个总连接数），而是只与 Facade 对话，这将相应地重定向请求。立面后面的所有东西对其他外部物体都是完全不透明的。

除了主要和明显的好处（对象的解耦）之外，这种模式还鼓励更简单的设计，更少的接口和更好的封装。

这种模式不仅可以用来改进我们领域问题的代码，还可以用来创建更好的 API。如果我们使用这种模式并提供单一界面，作为我们代码的单一事实点或入口点，我们的用户将更容易与公开的功能进行交互。不仅如此，通过暴露一个功能并将所有内容隐藏在接口后面，我们可以随意更改或重构底层代码，因为只要它在外观后面，就不会破坏向后兼容性，并且我们的用户不会受到影响。

请注意，这种使用外观的想法甚至不仅限于对象和类，还适用于包（从技术上讲，包是 Python 中的对象，但仍然如此）。我们可以使用外观的这种想法来决定包的布局；也就是说，什么对用户可见且可导入，什么是内部的，不应直接导入。

当我们创建一个目录来构建包时，我们将 \_\_init\_\_.py 文件与其余文件一起放置。这是模块的根，一种外观。其余文件定义要导出的对象，但它们不应由客户端直接导入。 \_\_init\_\_.py 文件应该导入它们，然后客户端应该从那里获取它们。这创建了一个更好的界面，因为用户只需要知道从中获取对象的单个入口点，更重要的是，包（其余文件）可以根据需要多次重构或重新排列，而这不会只要维护 init 文件上的主要 API，就会影响客户端。为了构建可维护的软件，牢记这样的原则至关重要。

Python 本身有一个例子，带有 os 模块。该模块对操作系统的功能进行分组，但在其下方，使用 posix 模块用于可移植操作系统接口 (POSIX) 操作系统（在 Windows 平台上称为 nt）。这个想法是，出于可移植性的原因，我们不应该真正直接导入 posix 模块，而应该始终导入 os 模块。由该模块决定从哪个平台调用它并公开相应的功能。

### 行为模式

行为模式旨在解决对象应该如何合作、它们应该如何通信以及它们的接口在运行时应该是什么的问题。

我们主要讨论以下行为模式：

- 责任链
- 模板方法
- 命令
- 状态

这可以通过继承的方式静态完成，也可以通过组合动态地完成。无论模式使用什么，我们将在以下示例中看到的是，这些模式的共同点是结果代码在某些重要方面更好，无论是因为它避免了重复还是创建了封装好的抽象相应的行为并解耦我们的模型。

#### 责任链

现在我们要再看看我们的事件系统。我们希望从日志行（例如，从我们的 HTTP 应用程序服务器转储的文本文件）解析有关系统上发生的事件的信息，我们希望以一种方便的方式提取这些信息。

在我们之前的实现中，我们实现了一个有趣的解决方案，它符合开闭原则，依靠使用 \_\_subclasses\_\_() 魔术方法来发现所有可能的事件类型并使用正确的事件处理数据，通过解决责任封装在每个类上的方法。

该解决方案适用于我们的目的，并且具有很强的可扩展性，但正如我们将看到的，这种设计模式将带来额外的好处。

这里的想法是我们将以稍微不同的方式创建事件。每个事件仍然具有确定它是否可以处理特定日志行的逻辑，但它也会有一个后继者。此后继事件是一个新事件，即行中的下一个事件，它将继续处理文本行，以防第一个事件无法执行此操作。逻辑很简单——我们将事件链接起来，每个事件都试图处理数据。如果可以，那么它只返回结果。如果不能，它会将它传递给它的后继者并重复，如以下代码所示：

```python
import re
from typing import Optional, Pattern
class Event:
    pattern: Optional[Pattern[str]] = None
    def __init__(self, next_event=None):
        self.successor = next_event
    def process(self, logline: str):
        if self.can_process(logline):
            return self._process(logline)
        if self.successor is not None:
            return self.successor.process(logline)
    def _process(self, logline: str) -> dict:
        parsed_data = self._parse_data(logline)
        return {
            "type": self.__class__.__name__,
            "id": parsed_data["id"],
            "value": parsed_data["value"],
        }
    @classmethod
    def can_process(cls, logline: str) -> bool:
        return (
            cls.pattern is not None and cls.pattern.match(logline) is not None
        )
    @classmethod
    def _parse_data(cls, logline: str) -> dict:
        if not cls.pattern:
            return {}
        if (parsed := cls.pattern.match(logline)) is not None:
            return parsed.groupdict()
        return {}
class LoginEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+login\s+(?P<value>\S+)")
class LogoutEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+logout\s+(?P<value>\S+)")
```

通过这个实现，我们创建了事件对象，并按照它们将被处理的特定顺序排列它们。 由于它们都有一个 process() 方法，因此它们对于此消息是多态的，因此它们对齐的顺序对客户端是完全透明的，并且它们中的任何一个也是透明的。 不仅如此，process()方法也有同样的逻辑； 如果提供的数据对于处理它的对象类型是正确的，它会尝试提取信息，如果不正确，它会移至该行中的下一个。

这样，我们可以通过以下方式处理登录事件：

```python
>>> chain = LogoutEvent(LoginEvent())
>>> chain.process("567: login User")
{'type': 'LoginEvent', 'id': '567', 'value': 'User'}
```

请注意 LogoutEvent 如何接收 LoginEvent 作为其后继者，并且当它被要求处理无法处理的事情时，它会重定向到正确的对象。从字典上的类型键可以看出，LoginEvent 是实际创建该字典的那个。

这个解决方案足够灵活，并且与我们之前的解决方案共享一个有趣的特征——所有条件都是互斥的。只要没有冲突，并且没有一条数据有多个处理程序，以任何顺序处理事件都不是问题。

但是如果我们不能做出这样的假设呢？使用之前的实现，我们仍然可以更改 \_\_subclasses\_\_() 调用我们根据我们的标准制作的列表，这会工作得很好。如果我们希望在运行时（例如，由用户或客户端）确定优先顺序呢？那将是一个缺点。

使用新的解决方案，可以满足这些要求，因为我们在运行时组装链，以便我们可以根据需要动态操作它。

例如，现在我们添加一个对登录和注销会话事件进行分组的通用类型，如以下代码所示：

```python
class SessionEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+log(in|out)\s+(?P<value>\S+)")
```

如果出于某种原因，在应用程序的某些部分，我们想在登录事件之前捕获它，这可以通过以下链来完成：

```python
chain = SessionEvent(LoginEvent(LogoutEvent()))
```

例如，通过更改顺序，我们可以说通用会话事件的优先级高于登录，但不是注销，等等。

这种模式与对象一起工作的事实使它相对于我们之前的实现更加灵活，它依赖于类（虽然它们在 Python 中仍然是对象，但它们并没有被排除在某种程度的刚性之外）。

#### 模板方法

模板方法是一种在正确实施时会产生重要好处的模式。主要是，它允许我们重用代码，它还使我们的对象更灵活，更容易更改，同时保留多态性。

这个想法是有一个定义一些行为的类层次结构，让我们说它的公共接口的一个重要方法。层次结构的所有类共享一个公共模板，可能只需要更改其中的某些元素。那么，这个想法是将这个通用逻辑放在父类的公共方法中，该方法将在内部调用所有其他（私有）方法，而这些方法是派生类将要修改的方法；因此，模板中的所有逻辑都被重用。

细心的读者可能已经注意到我们已经在上一节中实现了这个模式（作为责任链示例的一部分）。请注意，派生自 Event 的类在其特定模式中仅实现一件事。对于其余的逻辑，模板位于 Event 类中。 process 事件是通用的，依赖于两个辅助方法：can_process() 和 process()（依次调用 _parse_data()）。

这些额外的方法依赖于类属性模式。因此，为了使用新类型的对象扩展它，我们只需要创建一个新的派生类并放置正则表达式。之后，其余的逻辑将随着这个新属性的改变而被继承。这会重用大量代码，因为处理日志行的逻辑在父类中定义一次且仅一次。

这使得设计灵活，因为保留多态性也很容易实现。如果我们需要一个新的事件类型，由于某种原因需要一种不同的数据解析方式，我们只在该子类中覆盖这个私有方法，并且兼容性将保持，只要它返回与原始类型相同的类型（符合 Liskov 的替代和开放/封闭原则）。这是因为它是从派生类调用方法的父类。

如果我们正在设计自己的库或框架，这种模式也很有用。通过以这种方式安排逻辑，我们使用户能够很容易地更改其中一个类的行为。他们必须创建一个子类并覆盖特定的私有方法，结果将是一个具有新行为的新对象，该对象保证与原始对象的先前调用者兼容。

#### 命令
命令模式使我们能够将需要执行的操作从请求执行到实际执行的那一刻分开。不仅如此，它还可以将客户端发出的原始请求与其接收者分开，后者可能是不同的对象。在本节中，我们将主要关注模式的第一个方面：我们可以将订单的运行方式与实际执行时间分开。

我们知道我们可以通过实现 __call__() 魔法方法来创建可调用对象，所以我们可以初始化对象，然后稍后调用它。事实上，如果这是唯一的要求，我们甚至可以通过嵌套函数来实现，该函数通过闭包创建另一个函数来实现延迟执行的效果。但是这种模式可以扩展到不容易实现的目的。

这个想法是命令也可能在其定义后被修改。这意味着客户端指定要运行的命令，然后可能会更改其某些参数、添加更多选项等等，直到有人最终决定执行该操作。

这方面的例子可以在与数据库交互的库中找到。例如，在 psycopg2（一个 PostgreSQL 客户端库）中，我们建立了一个连接。由此，我们得到一个游标，然后我们可以向该游标传递一条 SQL 语句来运行。当我们调用 execute 方法时，对象的内部表示发生了变化，但实际上没有在数据库中运行。正是当我们调用 fetchall()（或类似方法）时，数据才真正被查询并在游标中可用。

在流行的对象关系映射器 SQLAlchemy (ORM SQLAlchemy) 中也会发生同样的情况。一个查询是通过几个步骤定义的，一旦我们有了查询对象，我们仍然可以与它进行交互（添加或删除过滤器、更改条件、申请订单等），直到我们决定我们想要的结果查询。调用每个方法后，查询对象更改其内部属性并返回self（本身）。

这些示例类似于我们想要实现的行为。创建此结构的一种非常简单的方法是使用一个对象来存储要运行的命令的参数。之后，它还必须提供与这些参数交互的方法（添加或删除过滤器等）。或者，我们可以向该对象添加跟踪或日志记录功能，以审计已发生的操作。最后，我们需要提供一个方法来实际执行操作。这个可以只是 \_\_call\_\_() 或自定义的。我们称之为 do()。

当我们处理异步编程时，这种模式很有用。正如我们所见，异步编程具有语法上的细微差别。通过将命令的准备与执行分开，我们可以使前者仍然具有同步形式，而后者具有异步语法（假设这是需要异步运行的部分，例如，如果我们使用的是库以连接到数据库）。

#### 状态
状态模式是软件设计中具体化的一个明显例子，使我们的领域问题的概念成为一个明确的对象，而不仅仅是一个边值（例如，使用字符串或整数标志来表示值或管理状态）。

在第 8 章，单元测试和重构中，我们有一个表示合并请求的对象，并且它有一个与之关联的状态（打开、关闭等）。我们使用枚举来表示这些状态，因为在那时，它们只是保存值的数据（该特定状态的字符串表示）。如果他们必须有一些行为，或者整个合并请求必须根据其状态和转换执行一些操作，这还不够。

我们将行为、运行时结构添加到代码的一部分这一事实必须让我们从对象的角度进行思考，因为这毕竟是对象应该做的。物化来了——现在状态不能只是简单的带有字符串的枚举；它必须是一个对象。

想象一下，我们必须在合并请求中添加一些规则，比如当它从打开状态变为关闭状态时，所有的批准都会被移除（他们将不得不再次审查代码）——并且当一个合并请求刚刚打开时，数字批准数设置为零（无论它是重新打开的还是全新的合并请求）。另一个规则可能是当一个合并请求被合并时，我们要删除源分支，当然我们要禁止用户执行无效的转换（例如，一个关闭的合并请求不能被合并等等）。

如果我们将所有这些逻辑放在一个地方，即在 MergeRequest 类中，我们最终会得到一个具有很多职责（设计不佳的标志）、可能有很多方法和大量 if 语句的类.很难遵循代码并理解哪个部分应该代表哪个业务规则。

最好将其分配到较小的对象中，每个对象的职责较少，而状态对象是这样做的好地方。我们为我们想要表示的每种状态创建一个对象，并且在他们的方法中，我们将转换的逻辑置于上述规则中。然后 MergeRequest 对象将有一个状态协作器，而这又将了解 MergeRequest（需要双重调度机制来对 MergeRequest 运行适当的操作并处理转换）。

我们定义了一个带有要实现的方法集的基本抽象类，然后是我们想要表示的每个特定状态的子类。然后 MergeRequest 对象将所有操作委托给 state，如以下代码所示：

```python
class InvalidTransitionError(Exception):
    """Raised when trying to move to a target state from an unreachable 
    Source
    state.
    """
class MergeRequestState(abc.ABC):
    def __init__(self, merge_request):
        self._merge_request = merge_request
    @abc.abstractmethod
    def open(self):
        ...
    @abc.abstractmethod
    def close(self):
        ...
    @abc.abstractmethod
    def merge(self):
        ...
    def __str__(self):
        return self.__class__.__name__
class Open(MergeRequestState):
    def open(self):
        self._merge_request.approvals = 0
    def close(self):
        self._merge_request.approvals = 0
        self._merge_request.state = Closed
    def merge(self):
        logger.info("merging %s", self._merge_request)
        logger.info(
            "deleting branch %s", 
            self._merge_request.source_branch
        )
        self._merge_request.state = Merged
class Closed(MergeRequestState):
    def open(self):
        logger.info(
            "reopening closed merge request %s", 
            self._merge_request
        )
        self._merge_request.state = Open
    def close(self):
        """Current state."""
    def merge(self):
        raise InvalidTransitionError("can't merge a closed request")
class Merged(MergeRequestState):
    def open(self):
        raise InvalidTransitionError("already merged request")
    def close(self):
        raise InvalidTransitionError("already merged request")
    def merge(self):
        """Current state."""
class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self.source_branch = source_branch
        self.target_branch = target_branch
        self._state = None
        self.approvals = 0
        self.state = Open
    @property
    def state(self):
        return self._state
    @state.setter
    def state(self, new_state_cls):
        self._state = new_state_cls(self)
    def open(self):
        return self.state.open()
    def close(self):
        return self.state.close()
    def merge(self):
        return self.state.merge()
    def __str__(self):
        return f"{self.target_branch}:{self.source_branch}"
```

以下列表概述了有关实现细节和应该做出的设计决策的一些说明：

- 状态是一个属性，所以它不仅是公开的，而且还有一个地方定义了如何为合并请求创建状态，将 self 作为参数传递。
- 抽象基类不是严格需要的，但拥有它有好处。首先，它使我们正在处理的对象类型更加明确。其次，它强制每个子状态实现接口的所有方法。对此有两种选择：
    - 我们可以不编写方法并在尝试执行无效操作时让 AttributeError 引发，但这是不正确的，并且它没有表达发生了什么。
    - 与这一点相关的事实是，我们可以只使用一个简单的基类并将这些方法留空，但是不做任何事情的默认行为并没有让我们更清楚应该发生什么。如果子类中的方法之一不应该做任何事情（如合并的情况），那么最好让空方法坐在那里，并明确表示对于该特定情况，不应该做任何事情，而不是强制所有对象的逻辑。
- MergeRequest 和 MergeRequestState 相互链接。在进行转换的那一刻，前一个对象将不会有额外的引用并且应该被垃圾收集，因此这种关系应该始终是 1:1。考虑到一些小的和更详细的考虑，可能会使用弱参考。

以下代码显示了如何使用对象的一些示例：

```python
>>> mr = MergeRequest("develop", "mainline") 
>>> mr.open()
>>> mr.approvals
0
>>> mr.approvals = 3
>>> mr.close()
>>> mr.approvals
0
>>> mr.open()
INFO:log:reopening closed merge request mainline:develop
>>> mr.merge()
INFO:log:merging mainline:develop
INFO:log:deleting branch develop
>>> mr.close()
Traceback (most recent call last):
...
InvalidTransitionError: already merged request
```

转换状态的操作委托给 MergeRequest 始终持有的状态对象（这可以是 ABC 的任何子类）。 它们都知道如何响应相同的消息（以不同的方式），因此这些对象将针对每个转换采取相应的操作（删除分支、引发异常等），然后将 MergeRequest 移动到下一个状态。

由于 MergeRequest 将所有操作委托给它的状态对象，我们会发现这通常发生在每次它需要执行的操作采用 self.state.open() 形式时，等等。 我们可以删除一些样板吗？

我们可以通过 \_\_getattr\_\_()，如下面的代码所示：

```python
class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self.source_branch = source_branch
        self.target_branch = target_branch
        self._state: MergeRequestState
        self.approvals = 0
        self.state = Open
    @property
    def state(self) -> MergeRequestState:
        return self._state
    @state.setter
    def state(self, new_state_cls: Type[MergeRequestState]):
        self._state = new_state_cls(self)
    @property
    def status(self):
        return str(self.state)
    def __getattr__(self, method):
        return getattr(self.state, method)
    def __str__(self):
        return f"{self.target_branch}:{self.source_branch}"
```

在代码中实现这些类型的通用重定向时要小心，因为它可能会损害可读性。有时，最好有一些小样板，但要明确说明我们的代码做什么。

一方面，我们重用一些代码并删除重复行是好的。这使抽象基类更有意义。在某个地方，我们希望记录所有可能的操作，并在一个地方列出。那个地方曾经是 MergeRequest 类，但现在这些方法都没有了，所以唯一剩下的真相来源是 MergeRequestState。幸运的是，状态属性上的类型注释对于用户知道在哪里查找接口定义非常有帮助。

用户可以简单地看一看，看到 MergeRequest 没有的所有内容都将被询问其状态属性。从 init 定义来看，注解会告诉我们这是一个 MergeRequestState 类型的对象，通过查看这个接口，我们会看到我们可以安全地请求 open()、close() 和 merge() 方法在上面。

### 空对象模式

空对象模式是一种与本书前几章中提到的良好实践相关的想法。在这里，我们正在将它们形式化，并为这个想法提供更多的背景和分析。

原理相当简单——函数或方法必须返回一致类型的对象。如果这是有保证的，那么我们代码的客户端就可以使用通过多态返回的对象，而无需对它们运行额外的检查。

在前面的例子中，我们探讨了 Python 的动态特性如何使大多数设计模式的事情变得更容易。在某些情况下，它们会完全消失，而在其他情况下，它们更容易实施。设计模式最初被认为的主要目标是方法或函数不应该显式命名它们工作所需的对象的类。出于这个原因，他们建议创建接口和重新排列对象的方法，使它们适合这些接口，以便修改设计。但大多数时候，这在 Python 中是不需要的，我们可以只传递不同的对象，只要它们尊重它们必须拥有的方法，那么解决方案就会奏效。

另一方面，对象不一定必须遵守接口这一事实要求我们更加小心从这些方法和函数返回的东西。就像我们的函数没有对它们接收到的内容做出任何假设一样，假设我们代码的客户端也不会做出任何假设也是公平的（提供兼容的对象是我们的责任）。这可以通过合同设计来强制执行或验证。在这里，我们将探索一个简单的模式来帮助我们避免此类问题。

考虑上一节中探讨的责任链设计模式。我们看到了它是多么的灵活以及它的许多优点，例如将职责分离成更小的对象。它存在的问题之一是我们实际上永远不知道最终会处理消息的对象（如果有的话）。特别是，在我们的示例中，如果没有合适的对象来处理日志行，则该方法将简单地返回 None。

我们不知道用户将如何使用我们传递的数据，但我们知道他们期待一本字典。因此，可能会出现以下错误：

```python
AttributeError: 'NoneType' object has no attribute 'keys'
```

在这种情况下，修复相当简单—— process() 方法的默认值应该是一个空字典而不是 None。

> 确保返回类型一致的对象。

但是如果该方法返回的不是字典，而是我们域的自定义对象呢？

为了解决这个问题，我们应该有一个类来表示该对象的空状态并返回它。如果我们有一个代表我们系统中用户的类，以及一个通过用户 ID 查询用户的函数，那么在没有找到用户的情况下，它应该做以下两件事之一：

- 引发异常
- 返回 UserUnknown 类型的对象

但在任何情况下都不应该返回 None。短语 None 不代表刚刚发生的事情，调用者可能会合法地尝试向它询问方法，但它会因 AttributeError 失败。

我们之前已经讨论过异常及其优缺点，所以我们应该提到这个空对象应该与原始用户具有相同的方法，并且对它们中的每一个都不做任何事情。

使用这种结构的好处是我们不仅可以避免运行时的错误，而且这个对象可能很有用。它可以使代码更容易测试，甚至可以帮助调试（也许我们可以将日志记录到方法中以了解为什么达到该状态，向其提供了哪些数据，等等）。

通过利用 Python 的几乎所有魔法方法，可以创建一个通用的 null 对象，无论它如何调用，它都绝对不做任何事情，但几乎可以从任何客户端调用它。这样的对象会稍微类似于 Mock 对象。由于以下原因，不建议走这条路：

- 它失去了域问题的意义。回到我们的例子中，拥有一个 UnknownUser 类型的对象是有意义的，并且让调用者清楚地知道查询出了问题。
- 它不尊重原始界面。这是有问题的。请记住，重点是 UnknownUser 是用户，因此它必须具有相同的方法。如果调用者不小心请求了一个不存在的方法，那么在这种情况下，它应该引发一个 AttributeError 异常，这会很好。使用可以做任何事情并响应任何事情的通用空对象，我们将丢失这些信息，并且错误可能会潜入。如果我们选择创建一个带有 spec=User 的 Mock 对象，那么这个异常将被捕获，但同样，使用 Mock 对象来表示实际上是空状态的内容与我们提供清晰易懂代码的意图不符。

这种模式是一个很好的实践，它允许我们在我们的对象中保持多态性。

## 关于设计模式的最终思考

我们已经在 Python 中看到了设计模式的世界，在这样做的过程中，我们找到了常见问题的解决方案，以及更多有助于我们实现简洁设计的技术。

所有这些听起来不错，但它引出了一个问题：设计模式有多好？有些人认为它们弊大于利，因为它们是为类型系统有限（并且缺乏一流的函数）使得无法完成我们通常在 Python 中做的事情的语言而创建的。其他人声称设计模式强制设计解决方案，产生一些偏见，限制了本来会出现的设计，而这本来会更好。让我们依次看看这些点中的每一个。

### 模式对设计的影响

设计模式本身不能好坏，而取决于它的实现或使用方式。在某些情况下，如果使用更简单的解决方案就不需要设计模式。试图强制一个不适合的模式是一种过度设计的情况，这显然是不好的，但这并不意味着设计模式有问题，而且很可能在这些场景中，问题是甚至与模式完全无关。有些人试图过度设计一切，因为他们不明白灵活和适应性强的软件的真正含义。

正如我们之前在本书中提到的，制作好的软件不是要预测未来的需求（做未来学没有意义），而只是解决我们现在手头上的问题，以不妨碍我们的方式将来对其进行更改。它现在不必处理这些变化；它只需要足够灵活，以便将来可以修改。当那个未来到来时，在提出通用解决方案或适当的抽象之前，我们仍然必须记住同一问题的三个或更多实例的规则。

这通常是设计模式应该出现的点，一旦我们正确识别了问题并且可以相应地识别模式和抽象。

让我们回到模式对语言的适用性的话题。正如我们在本章介绍中所说，设计模式是高级思想。它们通常是指对象之间的关系及其交互。很难想象这样的事情会从一种语言消失到另一种语言。

确实，某些模式在 Python 中需要较少的工作，例如迭代器模式（本书前面曾详细讨论过，它是用 Python 构建的）或策略（因为相反，我们只需像任何其他常规对象一样传递函数；我们不需要将策略方法封装到一个对象中，因为函数本身就是那个对象）。

但是实际上还需要其他模式，它们确实可以解决问题，就像装饰器和复合模式的情况一样。在其他情况下，Python 本身实现了一些设计模式，但我们并不总是看到它们，就像我们在本章前面讨论的外观模式一样。

至于我们的设计模式导致我们的解决方案走向错误的方向，我们在这里必须小心。再一次，如果我们通过从领域问题的角度思考并创建正确的抽象来开始设计我们的解决方案，然后再看看是否有从该设计中产生的设计模式，那就更好了。让我们说它确实如此。那是一件坏事？事实上，我们试图解决的问题已经有了解决方案，这并不是一件坏事。重新发明轮子是不好的，就像在我们的领域中多次发生的那样。此外，事实上，我们正在应用一种已经被证明和验证的模式，这应该让我们对我们正在构建的质量更有信心。

### 作为理论的设计模式

我将设计模式视为软件工程理论的一种有趣方式。虽然我同意代码发展得越自然越好，但这并不意味着我们应该完全忽略设计模式。

存在设计模式是因为没有必要重新发明轮子。如果已经针对特定类型的问题设计了解决方案，那么在我们计划设计时可以节省一些时间来思考该想法。在这个意义上（并再次引用第一章中的类比），我喜欢将设计模式视为类似于国际象棋开局：职业棋手不会在游戏的早期阶段考虑每种组合。这就是理论。已经研究过了。这与数学或物理公式相同。你应该第一次就深刻理解它，知道如何推断它，并结合它的含义，但之后，没有必要一遍又一遍地发展那个理论。

作为软件工程的从业者，我们应该利用设计模式理论来节省脑力，更快地提出解决方案。更重要的是，设计模式不仅应该成为语言，还应该成为构建块。

### 我们模型中的名称

我们应该提到我们在代码中使用了设计模式吗？

如果设计好并且代码干净，它应该不言自明。出于以下几个原因，不建议您以所使用的设计模式命名：

我们代码的用户和其他开发人员不需要知道代码背后的设计模式，只要它按预期工作即可。
陈述设计模式破坏了意图揭示原则。将设计模式的名称添加到类中会使其失去部分原始含义。如果一个类代表一个查询，它应该被命名为 Query 或 EnhancedQuery，这表明该对象应该做什么的意图。 EnhancedQueryDecorator 没有任何意义，Decorator 后缀造成的混乱多于清晰。
在文档字符串中提及设计模式可能是可以接受的，因为它们作为文档工作，并且在我们的设计中表达设计思想（再次，交流）是一件好事。然而，这不应该是必要的。然而，大多数时候，我们不需要知道设计模式的存在。

最好的设计是那些设计模式对用户完全透明的设计。这方面的一个例子是外观模式如何出现在标准库中，使其对用户如何访问 os 模块完全透明。一个更优雅的例子是迭代器设计模式是如何被语言完全抽象的，我们甚至不必考虑它。

## 总结

设计模式一直被视为常见问题的成熟解决方案。这是一个正确的评估，但在本章中，我们从良好的设计技术和利用干净代码的模式的角度探讨了它们。在大多数情况下，我们研究了它们如何提供良好的解决方案来保留多态性、减少耦合以及创建根据需要封装细节的正确抽象——所有与第 8 章单元测试和重构中探讨的概念相关的特征。

尽管如此，关于设计模式的最好的事情不是我们可以通过应用它们获得的干净的设计，而是扩展的词汇。作为一种交流工具，我们可以用他们的名字来表达我们设计的意图。有时，我们不需要应用整个模式，但我们可能需要从我们的解决方案中获取模式的特定想法（例如子结构），在这里，它们也被证明是一种交流方式更有效。

当我们通过模式思考来创建解决方案时，我们是在更一般的层面上解决问题。从设计模式的角度思考让我们更接近更高层次的设计。我们可以慢慢“缩小”，在架构方面多思考。现在我们正在解决更普遍的问题，是时候开始考虑系统将如何发展和长期维护（如何扩展、改变、适应等）。

软件项目要成功实现这些目标，其核心代码需要干净，但架构也必须干净，这就是我们将在下一章中讨论的内容。

## 参考

以下是您可以参考的信息列表：

GoF：由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 编写的书《设计模式：可重用面向对象软件的元素》
SNGMONO：Robert C. Martin 于 2002 年撰写的一篇名为 SINGLETON 和 MONOSTATE 的文章：http://staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf
空对象模式，由 Bobby Woolf 编写

